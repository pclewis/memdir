/** @file misc.c
 *  Miscellaneous functions.
 */

/*
 * Copyright (C) 2006 Philip Lewis <pcl@pclewis.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/* compatibility stuff - must come first */
#include "compat.h"

#ifdef WIN32
#define _POSIX_
#include <limits.h> /* SSIZE_MAX */
#undef _POSIX_
#include <io.h>     /* lseek and friends */
#else /* !WIN32 */
#include <unistd.h>
#endif /* WIN32 */

/* glib */
#include <glib.h>
#include <glib/gstdio.h>

/* system */
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

/* our stuff */
#include "misc.h"
#include "test.h"

gboolean
file_exists(gchar *path)
{
  return g_access(path, F_OK) == 0;
}

gboolean
file_readable(gchar *path)
{
  return g_access(path, R_OK) == 0;
}

gboolean
file_writeable(char *path)
{
  return g_access(path, W_OK) == 0;
}

gboolean
rmrf(gchar *dirname)
{
  const gchar *file     = NULL;
  gchar       *fullpath = NULL;

  /* not a directory */
  if ( !g_file_test(dirname, G_FILE_TEST_IS_DIR) ) {
    /* g_unlink returns 0 on success, -1 on error */
    return g_unlink(dirname) == 0;
  } else {
    GDir *dir = g_dir_open(dirname, 0, NULL);

    if ( dir == NULL )
      return FALSE;

    while ( (file = g_dir_read_name(dir)) != NULL ) {
      gboolean result;
      fullpath = g_build_filename( dirname, file, NULL );
      result = rmrf( fullpath );
      g_free(fullpath);
      if ( !result )
        return FALSE;
    }

    g_dir_close(dir);
    return g_rmdir( dirname ) == 0;
  }
}


gchar *
urldecode(const gchar *str, gint *result_size)
{
  const gchar *p = NULL;
  gchar *result  = NULL;
  gchar *rp      = NULL;
  gint size      = 0;

  for ( p = str; *p != '\0'; ++p ) {
    /* skip valid percent sequences */
    if ( *p == '%' && g_ascii_isxdigit(*(p+1)) && g_ascii_isxdigit(*(p+2)) )
      p += 2;
    ++size;
  }

  result = g_malloc0(size + 1);
  for ( p = str, rp = result; *p != '\0'; ++p, ++rp ) {
    if ( *p == '%' && g_ascii_isxdigit(*(p+1)) && g_ascii_isxdigit(*(p+2)) ) {
      *rp = g_ascii_xdigit_value(*(p+1)) << 4 | g_ascii_xdigit_value(*(p+2));
      p += 2;
    } else {
      *rp = *p;
    }
  }

  if ( result_size != NULL )
    *result_size = size;

  return result;
}

#if UNITTEST
static TestResult
test_urldecode()
{
  struct {
    gchar *test;
    gchar *expected;
  } tests[] = {
    { "test incomplete %2",       "test incomplete %2" },
    { "test invalid %qq",         "test invalid %qq"   },
    { "test%20ok",                "test ok"            },
    { "test %6d%69%78%69%6E%67",  "test mixing"        },
    { "test%00binary",            "test\0binary"       },
    { "",                         ""                   },
    { NULL,                       NULL                 }
  };

  gint i;
  gint result_size;
  gchar *result;

  for ( i = 0; tests[i].test != NULL; i++ ) {
    result = urldecode(tests[i].test, &result_size);
    TEST_ASSERT( memcmp(tests[i].expected, result, result_size) == 0 );
    g_free(result);
  }
  TEST_DONE();
}
#endif /* UNITTEST */

int
safe_strcmp( const char *l, const char *r )
{
  if ( l == NULL && r == NULL ) return 0;
  if ( l == NULL && r != NULL ) return -1;
  if ( l != NULL && r == NULL ) return 1;
  return strcmp(l,r);
}

guint
hash_int64( gconstpointer p )
{
  return (guint)(*(gint64 *)p);
}

gboolean
equal_int64( gconstpointer a, gconstpointer b )
{
  return *((gint64 *)a) == *((gint64 *)b);
}

/*
guint
hash_message( gconstpointer p )
{
  const Message *message = p;
  return (guint)(message->id);
}

gboolean
equal_message( gconstpointer a, gconstpointer b )
{
  return ((const Message *)a)->id == ((const Message *)b)->id;
}
*/

/****************************************************************************/
/****************************************************************************/

static GError *test_error      = NULL;

/* setup mock functions {{{ */

TEST_MOCK( off_t, lseek, (int fd, off_t offset, int whence),
           (fd, offset, whence) );
#define lseek test_mock_lseek

TEST_MOCK( ssize_t, read, (int fd, void *buf, size_t count),
           (fd, buf, count) );
#define read test_mock_read

TEST_MOCK( ssize_t, write, (int fd, const void *buf, size_t count),
           (fd, buf, count) );
#define write test_mock_write

TEST_MOCK( int, g_open, (const gchar *filename, int flags, int mode),
           (filename, flags, mode) );
#undef g_open
#define g_open test_mock_g_open

/* }}} */

/****************************************************************************/
/****************************************************************************/

/** Same as lseek(2), but sets error on failure. Additionally, if the 
 *  resulting offset of a SEEK_SET call is not the requested offset, error is 
 *  set and -1 is returned.
 *
 *  @return
 *    The new file offset on success, or -1 on error.
 */
off_t
safe_lseek( int fd, off_t offset, int whence, GError **error )
{
  off_t result;

  g_assert( fd     >= 0 );
  g_assert( whence == SEEK_SET || whence == SEEK_CUR || whence == SEEK_END );
  g_assert( whence != SEEK_SET || offset >= 0 );
  g_assert( error  == NULL     || *error == NULL );

  result = lseek(fd, offset, whence);

  if ( result == -1 ) {
    g_set_error( error, MISC_ERROR, MISC_ERROR_SEEK,
                 "lseek(%d, %ld, %d): %s", fd, (long)offset, whence,
                 g_strerror(errno) );
  } else if ( whence == SEEK_SET && result != offset ) {
    g_set_error( error, MISC_ERROR, MISC_ERROR_SEEK,
                 "lseek(%d, %ld, %d): ended up at %ld, wanted %ld",
                 fd, (long)offset, whence,
                 (long)result, (long)offset );
  }
  return result;
}

#if UNITTEST /*{{{*/
static TestResult
test_safe_lseek()
{
  off_t result  = -1;

  /* test valid fd */
  result = safe_lseek( test_temp_fd, 0, SEEK_SET, &test_error );
  TEST_ASSERT_EQUAL_INT( result, 0 );
  TEST_ASSERT_NO_ERROR( test_error );

  /* bad: invalid offset */
  result = safe_lseek( test_temp_fd, -1, SEEK_CUR, &test_error );
  TEST_ASSERT_EQUAL_INT( result, -1 );
  TEST_ASSERT_ERROR( test_error, MISC_ERROR, MISC_ERROR_SEEK );

  /* good: past eof */
  result = safe_lseek( test_temp_fd, 100, SEEK_SET, &test_error );
  TEST_ASSERT_EQUAL_INT( result, 100 );
  TEST_ASSERT_NO_ERROR( test_error );

  /* lseek shouldn't extend the file */
  result = safe_lseek( test_temp_fd, 0, SEEK_END, &test_error );
  TEST_ASSERT_EQUAL_INT( result, 0 );
  TEST_ASSERT_NO_ERROR( test_error );

  /* try invalid fd */
  test_set_mock_return_lseek( -1 );
  test_set_mock_errno_lseek( EINVAL );
  result = safe_lseek( test_temp_fd, 100, SEEK_SET, &test_error );
  TEST_ASSERT_EQUAL_INT( result, -1 );
  TEST_ASSERT_ERROR( test_error, MISC_ERROR, MISC_ERROR_SEEK );

  /* try mismatched seek */
  test_set_mock_return_lseek( 5 );
  result = safe_lseek( test_temp_fd, 100, SEEK_SET, &test_error );
  TEST_ASSERT_EQUAL_INT( result, 5 );
  TEST_ASSERT_ERROR( test_error, MISC_ERROR, MISC_ERROR_SEEK );

  TEST_DONE();
}
#endif /* UNITTEST */ /*}}}*/

/****************************************************************************/
/****************************************************************************/

/** same as write(2), but sets error on failure */
ssize_t
safe_write( int fd, const void *buf, size_t count, GError **error )
{
  ssize_t result;

  g_assert( fd    >= 0 );
  g_assert( count == 0    || buf    != NULL );
  g_assert( count <= SSIZE_MAX ); /* "If the value of nbyte is greater
                                     than {SSIZE_MAX}, the result is
                                     implementation-defined." */
  g_assert( error == NULL || *error == NULL );

  result = write( fd, buf, count );

  if ( result < 0 ) {
    if ( errno == ENOSPC ) {
      g_set_error( error, MISC_ERROR, MISC_ERROR_DISK_SPACE,
                  "%s when writing %u bytes to fd %d",
                  g_strerror(errno),
                  (guint)count, fd );
    } else {
      g_set_error( error, MISC_ERROR, MISC_ERROR_WRITE,
                  "write(%d, %p, %u): %s", fd, buf, (guint)count,
                  g_strerror(errno) );
    }
  } else if ( (size_t)result != count ) {
    g_set_error( error, MISC_ERROR, MISC_ERROR_WRITE,
                 "write(%d, %p, %u): only wrote %u bytes",
                 fd, buf, (guint)count,
                 (guint)result );
  }

  return result;
}

#if UNITTEST /* {{{ */
static TestResult
test_safe_write()
{
  ssize_t    result = -1;
  const char data[] = "TEST";
  char       buf[5];

  /* test write 0 bytes */
  result = safe_write( test_temp_fd, "", 0, &test_error );
  TEST_ASSERT_EQUAL_INT( result, 0 );
  TEST_ASSERT_NO_ERROR( test_error );

  /* write some data */
  result = safe_write( test_temp_fd, data, sizeof(data), &test_error );
  TEST_ASSERT_EQUAL_INT( result, sizeof(data) );
  TEST_ASSERT_NO_ERROR( test_error );

  /* make sure pos is right */
  result = lseek( test_temp_fd, 0, SEEK_END );
  TEST_ASSERT_EQUAL_INT( result, sizeof(data) );

  /* make sure it reads back right */
  result = lseek( test_temp_fd, 0, SEEK_SET );
  g_assert( result == 0 );
  result = read( test_temp_fd, buf, sizeof(data) );
  g_assert( result == sizeof(data) );
  TEST_ASSERT_EQUAL_STR( buf, data );

  /* test invalid fd */
  test_set_mock_return_write( -1 );
  test_set_mock_errno_write( EINVAL );
  result = safe_write( test_temp_fd, "", 0, &test_error );
  TEST_ASSERT_EQUAL_INT( result, -1 );
  TEST_ASSERT_ERROR( test_error, MISC_ERROR, MISC_ERROR_WRITE );

  /* test out of space */
  test_set_mock_return_write( -1 );
  test_set_mock_errno_write( ENOSPC );
  result = safe_write( test_temp_fd, data, sizeof(data), &test_error );
  TEST_ASSERT_EQUAL_INT( result, -1 );
  TEST_ASSERT_ERROR(test_error, MISC_ERROR, MISC_ERROR_DISK_SPACE);

  /* test count mismatch */
  test_set_mock_return_write( sizeof(data)-1 );
  result = safe_write( test_temp_fd, data, sizeof(data), &test_error );
  TEST_ASSERT_EQUAL_INT( result, sizeof(data)-1 );
  TEST_ASSERT_ERROR(test_error, MISC_ERROR, MISC_ERROR_WRITE);

  TEST_DONE();
}
#endif /* UNITTEST */ /* }}} */

/****************************************************************************/
/****************************************************************************/

/** same as read(2), but sets error on failure */
ssize_t
safe_read( int fd, void *buf, size_t count, GError **error )
{
  ssize_t result;

  g_assert( fd    >= 0 );
  g_assert( count == 0    ||  buf   != NULL );
  g_assert( count <= SSIZE_MAX ); /* "If the value of nbyte is greater
                                     than {SSIZE_MAX}, the result is
                                     implementation-defined." */
  g_assert( error == NULL || *error == NULL );

  result = read( fd, buf, count );

  if ( result < 0 ) {
    /* todo: retry on EINTR? */
    g_set_error( error, MISC_ERROR, MISC_ERROR_READ,
                 "read(%d, %p, %u): %s", fd, buf, (guint)count,
                 g_strerror(errno) );
  } else if ( (size_t)result != count ) {
    g_set_error( error, MISC_ERROR, MISC_ERROR_EOF,
                 "read(%d, %p, %u): wanted %u bytes, got %u", fd, buf,
                 (guint)count, (guint)count, (guint)result );
  }

  return result;
}

#if UNITTEST /* {{{ */
static TestResult
test_safe_read()
{
  ssize_t    result = -1;
  const char data[] = "TEST";
  char       buf[5];

  /* test reading bytes that arent there */
  result = safe_read( test_temp_fd, buf, 1, &test_error );
  TEST_ASSERT_EQUAL_INT( result, 0 );
  TEST_ASSERT_ERROR( test_error, MISC_ERROR, MISC_ERROR_EOF );

  /* write some data */
  result = write( test_temp_fd, data, sizeof(data) );
  g_assert( result == sizeof(data) );

  /* make sure it reads back right */
  result = lseek( test_temp_fd, 0, SEEK_SET );
  g_assert( result == 0 );
  result = safe_read( test_temp_fd, buf, sizeof(data), &test_error );
  TEST_ASSERT_EQUAL_INT( result, sizeof(data) );
  TEST_ASSERT_NO_ERROR( test_error );
  TEST_ASSERT_EQUAL_STR( buf, data );

  /* test invalid fd */
  test_set_mock_return_read( -1 );
  test_set_mock_errno_read( EINVAL );
  result = safe_read( test_temp_fd, buf, sizeof(data), &test_error );
  TEST_ASSERT_EQUAL_INT( result, -1 );
  TEST_ASSERT_ERROR( test_error, MISC_ERROR, MISC_ERROR_READ );

  /* test count mismatch */
  test_set_mock_return_read( sizeof(data)-1 );
  result = safe_read( test_temp_fd, buf, sizeof(data), &test_error );
  TEST_ASSERT_EQUAL_INT( result, sizeof(data)-1 );
  TEST_ASSERT_ERROR( test_error, MISC_ERROR, MISC_ERROR_EOF );

  TEST_DONE();
}
#endif /* UNITTEST */ /* }}} */

/****************************************************************************/
/****************************************************************************/

int
safe_open( const gchar *filename, gint flags, gint mode, GError **error )
{
  int result;

  g_assert( filename != NULL );
  /* make sure flags contains exactly on of O_RDONLY, O_WRONLY, or O_RDWR
   * clever ways of doing it are inhibited by one of them possibly being 0 */
  g_assert( (flags & (O_RDONLY|O_WRONLY|O_RDWR)) == O_RDONLY ||
            (flags & (O_RDONLY|O_WRONLY|O_RDWR)) == O_WRONLY ||
            (flags & (O_RDONLY|O_WRONLY|O_RDWR)) == O_RDWR );
  g_assert( error    == NULL || *error == NULL );

  result = g_open( filename, flags, mode );

  if ( result < 0 ) {
    g_set_error( error, MISC_ERROR, MISC_ERROR_OPEN,
                 "g_open(%s, %x, %x): %s", filename, flags, mode,
                 g_strerror(errno) );
  }

  return result;
}

#if UNITTEST /* {{{ */
static TestResult
test_safe_open()
{
  int   result   = -1;
  char *filename = "__memdir_tmp__";

  /* try opening a bogus file */
  /* FIXME: Apparently Windows creates the file whether O_CREAT is set or
   * not */
  /*
  result = safe_open( filename, O_RDONLY, 0, &test_error );
  TEST_ASSERT_EQUAL_INT( result, -1 );
  TEST_ASSERT_ERROR( test_error, MISC_ERROR, MISC_ERROR_OPEN );
  */

  /* try creating it */
  result = safe_open( filename, O_RDWR|O_CREAT,
                         S_IRUSR|S_IWUSR, &test_error );
  TEST_ASSERT( result >= 0 );
  TEST_ASSERT_NO_ERROR( test_error );
  close(result);

  /* open it back up */
  result = safe_open( filename, O_RDWR, 0, &test_error );
  TEST_ASSERT( result >= 0 );
  TEST_ASSERT_NO_ERROR( test_error );
  close(result);

  if ( g_unlink( filename ) != 0 ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
           "can't remove %s: %s",
           filename, g_strerror(errno) );
    errno = 0;
  }
  TEST_DONE();
}
#endif /* UNITTEST */ /* }}} */

/****************************************************************************/
/****************************************************************************/

#ifdef UNITTEST
void
test_suite_misc() {
  TEST_RUN_TEST(test_urldecode);

  test_suite_set_setup(test_temp_file_setup);
  test_suite_set_teardown(test_temp_file_teardown);
  TEST_RUN_TEST(test_safe_lseek);
  TEST_RUN_TEST(test_safe_write);
  TEST_RUN_TEST(test_safe_read);
  TEST_RUN_TEST(test_safe_open);
}
#endif
