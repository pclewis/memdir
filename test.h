/** @file test.h
 *  Testing framework declarations.
 */

/*
 * Copyright (C) 2006 Philip Lewis <pcl@pclewis.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef _TEST_H_
#define _TEST_H_ 1

/** Assert that a condition is true.
 */
#define TEST_ASSERT(c) \
  test_assert( (c), G_STRINGIFY(c), G_STRLOC )

/** Indicate that a test case passed if no assertions failed. All cases should 
 *  end with this. */
#define TEST_DONE()                 \
  TEST_DONE_WITH_CLEANUP( ; );

#define TEST_DONE_WITH_CLEANUP(cleanup)   \
  G_STMT_START {                          \
  test_current_result = TEST_RESULT_DONE; \
  goto test_cleanup;                      \
  test_cleanup:                           \
  cleanup                                 \
  return test_current_result;             \
  } G_STMT_END

/** Immediately abort the current test case and return failure. */
#define TEST_FAIL()                         \
  G_STMT_START {                            \
    test_current_result = TEST_RESULT_FAIL; \
    goto test_cleanup;                      \
  } G_STMT_END

/** Abort the current test if an assertion fails.
 *  eg: \c TEST_REQUIRE( TEST_ASSERT( ptr != NULL ) );
 */
#define TEST_REQUIRE(c) \
  G_STMT_START { c; TEST_REQUIRE_PREVIOUS(); } G_STMT_END

/** Abort the current test if the last assertion failed. */
#define TEST_REQUIRE_PREVIOUS()                \
  G_STMT_START {                               \
    if ( !test_last_assertion_result) {        \
      test_current_result = TEST_RESULT_ERROR; \
      goto test_cleanup;                       \
    }                                          \
  } G_STMT_END

#define TEST_ASSERT_EQUAL_INT(actual, expected) \
  TEST_ASSERT_OP_INT( actual, ==, expected )

#define TEST_ASSERT_EQUAL_INT64(actual, expected) \
  TEST_ASSERT_OP_INT64( actual, ==, expected )

#define TEST_ASSERT_EQUAL_FLOAT(actual, expected) \
  TEST_ASSERT_OP_FLOAT( actual, ==, expected )

#define TEST_ASSERT_EQUAL_DOUBLE(actual, expected) \
  TEST_ASSERT_OP_DOUBLE( actual, ==, expected )

#define TEST_ASSERT_EQUAL_STR(actual, expected) \
  TEST_ASSERT_OP_STR( actual, ==, expected, strcmp )

#define TEST_ASSERT_EQUAL_STRING TEST_ASSERT_EQUAL_STR

#define TEST_ASSERT_EQUAL_STRCASE(actual, expected) \
  TEST_ASSERT_OP_STR( actual, ==, expected, g_ascii_strcasecmp )

#define TEST_ASSERT_EQUAL_STRING_CASE TEST_ASSERT_EQUAL_STRCASE

#define TEST_ASSERT_OP_INT(left, op, right)     \
  TEST_ASSERT_OP_FORMAT( left, op, right, "%d", "%d", gint, gint )

#define TEST_ASSERT_OP_INT64(left, op, right)     \
  TEST_ASSERT_OP_FORMAT( left, op, right, "%lld", "%lld", gint64, gint64 )

#define TEST_ASSERT_OP_FLOAT(left, op, right)   \
  TEST_ASSERT_OP_FORMAT( left, op, right, "%f", "%f", gfloat, gfloat )

#define TEST_ASSERT_OP_DOUBLE(left, op, right)  \
  TEST_ASSERT_OP_FORMAT( left, op, right, "%f", "%f", gdouble, gdouble )

#define TEST_ASSERT_OP_PTR(left, op, right)     \
  TEST_ASSERT_OP_FORMAT( left, op, right, "%p", "%p", gpointer, gpointer )

/** Assert that operation on two values returns true. Messages describing the
 *  assertion will display the values using the formats provided.
 *
 *  @param  left          The left side of the operation
 *  @param  op            The operator
 *  @param  right         The right side of the operation
 *  @param  left_format   The format string for displaying the left value
 *  @param  right_format  The format string for displaying the right value
 *  @param  left_type     The type of the left value
 *  @param  right_type    The type of the right value
 */
#define TEST_ASSERT_OP_FORMAT(left, op, right,           \
                              left_format, right_format, \
                              left_type, right_type)     \
  G_STMT_START {                                         \
    /* avoid double eval */                              \
    left_type  test_tmp_left  = (left_type)left;         \
    right_type test_tmp_right = (right_type)right;       \
    test_assert_op_format(                               \
      test_tmp_left op test_tmp_right,                   \
      G_STRINGIFY(op),                                   \
      G_STRINGIFY(left),              left_format,       \
      G_STRINGIFY(right),             right_format,      \
      G_STRLOC, test_tmp_left, test_tmp_right            \
    );                                                   \
  } G_STMT_END

/** Assert that operation on two strings returns true. Messages describing the
 *  assertion will display the contents of both strings. The operator is not
 *  applied to the strings directly, but to the result of strcmp() and 0.
 *
 *  @param  left  The left side of strcmp
 *  @param  op    The operator (ex: ==)
 *  @param  right The right side of strcmp
 *  @param  func  strcmp or strcasecmp or whatever.
 */
#define TEST_ASSERT_OP_STR(left, op, right, func)       \
  G_STMT_START {                                        \
    /* avoid double eval */                             \
    const gchar *test_tmp_left  = (left);               \
    const gchar *test_tmp_right = (right);              \
    test_assert_op_format(                              \
      (test_tmp_left != NULL && test_tmp_right != NULL) \
      && (func)(test_tmp_left,test_tmp_right) op 0,     \
      G_STRINGIFY(op),                                  \
      G_STRINGIFY(left),                "\"%s\"",       \
      G_STRINGIFY(right),               "\"%s\"",       \
      G_STRLOC, test_tmp_left, test_tmp_right           \
    );                                                  \
  } G_STMT_END

/** Assert that a pointer is NULL */
#define TEST_ASSERT_NULL(ptr)                      \
  test_assert( (ptr) == NULL,                      \
               G_STRINGIFY(ptr) " should be NULL", \
               G_STRLOC );

/** Assert that a pointer is NOT NULL */
#define TEST_ASSERT_NOT_NULL(ptr)                      \
  test_assert( (ptr) != NULL,                          \
               G_STRINGIFY(ptr) " should NOT be NULL", \
               G_STRLOC );

/** Assert that the specified error domain and number is set in the specified 
 *  variable. If set, messages describing the assertion will include the error 
 *  domain, number, and message. The error variable will be cleared afterward.
 *
 *  @param error      The error variable to check.
 *  @param ex_domain  The expected error domain.
 *  @param ex_code    The expected error code.
 */
#define TEST_ASSERT_ERROR(error, ex_domain, ex_code)     \
  G_STMT_START {                                         \
    test_assert_format(                                  \
      (error) != NULL &&                                 \
      (error)->domain == (ex_domain) &&                  \
      (error)->code == (ex_code),                        \
      G_STRLOC,                                          \
      "Didn't get expected error (%s:%d)\n\t"            \
      "Got: " G_STRINGIFY(error) " = (%s:%d): %s",       \
      g_quark_to_string(ex_domain), (ex_code),           \
      (error) ? g_quark_to_string((error)->domain) : "", \
      (error) ? (error)->code                      : 0,  \
      (error) ? (error)->message                   : ""  \
    );                                                   \
    g_clear_error(&(error));                             \
  } G_STMT_END;

/** Assert that any error is set in the specified variable. The error variable
 *  will be cleared afterward.
 *
 *  @param error      The error variable to check.
 */
#define TEST_ASSERT_ANY_ERROR(error) \
  G_STMT_START {                     \
    TEST_ASSERT_NOT_NULL( (error) ); \
    g_clear_error(&(error));         \
  } G_STMT_END;

/** Assert that there is no error set in the specified variable. If set, 
 *  messages describing the assertion will include the error domain, number, 
 *  and message. The error variable will be cleared afterward.
 *
 *  @param error The error variable to check.
 */
#define TEST_ASSERT_NO_ERROR(error)                      \
  G_STMT_START {                                         \
    test_assert_format(                                  \
      (error) == NULL,                                   \
      G_STRLOC,                                          \
      G_STRINGIFY(error) " = (%s:%d): %s",               \
      (error) ? g_quark_to_string((error)->domain) : "", \
      (error) ? (error)->code                      : 0,  \
      (error) ? (error)->message                   : ""  \
    );                                                   \
    g_clear_error(&(error));                             \
  } G_STMT_END;

/** Convenient way to create a mock function. You can use #define to have code 
 *  being tested call the mock function instead of a real function in order to 
 *  test all code paths. The mock function will have the same name as the real 
 *  function with the prefix test_mock_. To set the value that the mock 
 *  function should return, use test_set_mock_return_NAME(value). To set the 
 *  errno as well, use test_set_mock_errno_NAME(value);. To call a different 
 *  function, set the variable test_func_mock_NAME.
 *
 *  Ex:
 *  \code
 *    TEST_MOCK( ssize_t, read, (int fd, void *buf, size_t count),
 *              (fd, buf, count) );
 *    #define read test_mock_read
 *    ...
 *    test_set_mock_return_read( -1 );
 *    test_set_mock_errno_read( EINVAL );
 *    ...
 *    result = read( STDIN_FILENO, buffer, 1 );
 *    g_assert( result == -1 );
 *    g_assert( errno == EINVAL );
 *    errno = 0;
 *    result = read( STDIN_FILENO, buffer, 1 );
 *    g_assert( result == 1 );
 *    g_assert( errno == 0 );
 *  \endcode
 *
 *  @param type     The return type of the function (cannot be void).
 *  @param name     The name of the function to mock.
 *  @param argspec  The argument specifier for the function, in parenthesis.
 *  @param callspec The arguments to call the real function, in parenthesis.
 *
 *  @note
 *    The mock return value and errno will be cleared when the mock function
 *    is called. The errno is only used/cleared when a return value is set.
 *    If a custom function is set, it will be called every time, and must be
 *    cleared manually.
 */
#define TEST_MOCK( type, name, argspec, callspec )             \
  typedef type (*TestFuncMock_ ## name) argspec;               \
  static TestFuncMock_ ## name test_func_mock_ ## name;        \
  static type *test_return_mock_ ## name = NULL;               \
  static int  *test_errno_mock_  ## name = NULL;               \
  static type test_mock_ ## name argspec {                     \
    if ( test_func_mock_ ## name != NULL ) {                   \
      return (*test_func_mock_ ## name) callspec;              \
    } else if (test_return_mock_ ## name != NULL) {            \
      type result = *test_return_mock_ ## name;                \
      test_return_mock_ ## name = NULL;                        \
      if ( test_errno_mock_ ## name != NULL ) {                \
        errno = *test_errno_mock_ ## name;                     \
        test_errno_mock_ ## name = NULL;                       \
      }                                                        \
      return result;                                           \
    } else {                                                   \
      return name callspec;                                    \
    }                                                          \
  }                                                            \
  /* suppress unused warnings */                               \
  static void test_set_mock_return_ ## name ( type value )     \
    G_GNUC_UNUSED;                                             \
  static void test_set_mock_errno_ ## name ( int value )       \
    G_GNUC_UNUSED;                                             \
  static void test_set_mock_return_ ## name ( type value ) {   \
    static type v;                                             \
    v = value;                                                 \
    test_return_mock_ ## name = &v;                            \
  }                                                            \
  static void test_set_mock_errno_ ## name ( int value ) {     \
    static int v;                                              \
    v = value;                                                 \
    test_errno_mock_ ## name = &v;                             \
  }                                                            \
  /* eat trailing ; */                                         \
  static TestFuncMock_ ## name test_func_mock_ ## name = NULL  \

/** Base assertion handler.
 *
 *  @note
 *    Should not be used directly, use the TEST_ASSERT macros instead.
 */
gboolean test_assert(
  gboolean   condition,     /**< The condition to test */
  gchar     *description,   /**< A description of the condition */
  gchar     *location       /**< The location of the assertion in the source */
);

/** Formatted assertion handler 
 *
 *  @note
 *    Should not be used directly, use the TEST_ASSERT macros instead.
 */
gboolean test_assert_format(
  gboolean   condition, /**< The condition to test                          */
  gchar     *location,  /**< The location of the assertion in the source    */
  gchar     *format,    /**< Format string for description of the condition */
  ...                   /**< Format arguments                               */
);

/** Abstract interface for assertions on binary operations. The description of
 *  the assertion will include both values using the format specified.
 *
 *  @note
 *    Should not be used directly, use the TEST_ASSERT macros instead.
 */
gboolean test_assert_op_format(
  gboolean    condition,    /**< The condition to test (left operation right) */
  gchar      *operation,    /**< A string representation of the operation     */
  gchar      *left,         /**< The left side of the operation               */
  gchar      *format_left,  /**< Format string for displaying \p left         */
  gchar      *right,        /**< The right side of the operation              */
  gchar      *format_right, /**< Format string for displaying \p right        */
  gchar      *location,     /**< The location of the assertion in the source  */
  ...                       /**< The actual values of left and right.         */
);

/** Type that tests should return */
typedef enum {
  TEST_RESULT_DONE,
  TEST_RESULT_FAIL,
  TEST_RESULT_SKIP,
  TEST_RESULT_ERROR
} TestResult;

/** Type that test suites should return */
typedef void TestSuiteResult;

/** Function signature for tests */
typedef TestResult (*TestFunction)();

/** Function signature for suites */
typedef TestSuiteResult (*SuiteFunction)();

/** Function signature for setup function */
typedef void (*TestSetupFunction)();

/** Function signature for teardown function */
typedef void (*TestTearDownFunction)();

/** Run a single test */
void test_run_test(TestFunction test, gchar *title);

/** Run a single test named the same as its function name */
#define TEST_RUN_TEST(t) test_run_test(t, G_STRINGIFY(t))

/** Set a function to be run before each test in this suite */
void test_suite_set_setup(TestSetupFunction func);

/** Set a function to be run after each test in this suite */
void test_suite_set_teardown(TestTearDownFunction func);

/** Run a test suite */
void test_run_suite(SuiteFunction suite, gchar *title);

/** Create and return an option group with test driver options. */
GOptionGroup *test_get_option_group();

/* Run all tests */
int test_main();

/** The result of the most recent assertion */
extern gboolean test_last_assertion_result;

/** Temp var */
extern TestResult test_current_result;

/** Descriptor for temp file */
extern int test_temp_fd;

/** Test setup function for tests that need a temp file */
void test_temp_file_setup();

/** Test teardown function for tests that need a temp file */
void test_temp_file_teardown();

#endif /* !_TEST_H_ */
