/** @file memdir.h
 *  MemDir interface.
 *
 *  A MemDir is a directory full of files used for mostly-static memory.
 *  Allocating space in a MemDir creates a pointer in mmap'd memory space,
 *  as well as a 64-bit struct that can be used to reload the information 
 *  later. 
 *  
 *  MemDir files are divided into "chunks" which are some multiple of the 
 *  system page size. When there is insufficient space for a requested 
 *  allocation, the MemDir extends the current file or creates a new one, 
 *  opens the new chunk with mmap(2), and returns a memory pointer and 
 *  MemDirPointer. The previous chunk is kept open until all of the pointers 
 *  to it have been released with memdir_unref() or memdir_free().
 *
 *  When data is loaded that is not in an open chunk, its chunk is 
 *  reopened.
 *
 *  Note that MemDir is two words in CamelCase (eg MemDirPointer) and one word
 *  when delimited (eg memdir_free, MEMDIR_ERROR).
 */

/*
 * Copyright (C) 2007 Philip Lewis <pcl@pclewis.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef _MEMDIR_H_
#define _MEMDIR_H_ 1

/** size_t for MemDir allocs */
typedef gint32 MemDirSize;

/** An opaque data structure representing a MemDir */
typedef struct MemDir_ MemDir;

/** A "pointer" into a MemDir */
typedef struct {
  guint32 file_number;
  guint32 file_offset;
} MemDirPointer;

/** Error codes for MemDir operations */
typedef enum {
  MEMDIR_ERROR_OPEN,            /**< Error opening file                  */
  MEMDIR_ERROR_EXISTS,          /**< Directory already exists            */
  MEMDIR_ERROR_MKDIR,           /**< Error when creating directory       */
  MEMDIR_ERROR_RESIZE,          /**< Error when resizing file            */
  MEMDIR_ERROR_MMAP,            /**< Couldn't mmap file                  */
  MEMDIR_ERROR_MUNMAP,          /**< Couldn't munmap file                */
  MEMDIR_ERROR_DISK_SPACE,      /**< Out of disk space                   */
  MEMDIR_ERROR_CHUNK_SIZE,      /**< Chunk size is bigger than file size */
  MEMDIR_ERROR_FILE_SIZE,       /**< File size is smaller than sys page  */
  MEMDIR_ERROR_SIZE,            /**< Alloc is bigger than chunk size     */
  MEMDIR_ERROR_INVALID_DIR,     /**< Directory is not a MemDir           */
  MEMDIR_ERROR_INVALID_INFO,    /**< MemDir info file is invalid/corrupt */
  MEMDIR_ERROR_INVALID_POINTER, /**< Invalid MemDirPointer supplied      */
  MEMDIR_ERROR_INVALID_DATA     /**< Data doesn't belong to this map     */
} MemDirError;

/** Error domain for MemDir operations. Errors in this domain will be from
 *  the MemDirError enum. */
#define MEMDIR_ERROR g_quark_from_static_string("MemDir")

/** Create a MemDir directory.
 *
 *  @return
 *    TRUE on success, FALSE on failure.
 */
gboolean memdir_create(
  const gchar  *name,       /**< The directory to create         */
  guint         chunk_size, /**< The size of a single "chunk" of memory to be 
                              mapped at once. It should be a multiple of the 
                              system page size for best performance. 
                              Attempting to allocate more bytes than a full 
                              chunk will fail. An optimal value is the largest 
                              allocation you will need to make, rounded UP to 
                              the nearest system page size */
  guint         file_size,  /**< The size of a single file. MUST be a multiple 
                              of chunk_size. (1<<31) is the largest file that 
                              can be portably mmap'd on 32 bit systems. An 
                              ideal value is (1<<31) rounded DOWN to the 
                              nearest chunk size. */
  guint         alignment,  /**< Number of bytes to align allocs to */
  GError      **error       /**< A location for receiving errors */
) NONNULL((1));

/** Open a MemDir directory.
 *
 *  @return
 *    A pointer to a new MemDir, or NULL on error.
 */
MemDir *memdir_open(
  const gchar  *name,       /**< The directory to open                  */
  GError      **error       /**< Location for receiving errors          */
) NONNULL((1));

/** Allocate space in a MemDir.
 *
 * @return
 *    Pointer to newly allocated space, or NULL on error
 */

void *memdir_alloc(
  MemDir         *md,      /**< An open MemDir                       */
  MemDirSize     size,     /**< Bytes to allocate                    */
  MemDirPointer  *pointer, /**< Location for receiving MemDirPointer */
  GError        **error    /**< Location for receiving errors        */
) NONNULL((1));


/** Load data from MemDir.
 *
 *  @return
 *    A pointer to the data, or NULL on error.
 */
void *memdir_load(
  MemDir        *md,         /**< An open MemDir                      */
  MemDirPointer  pointer,    /**< Offset of string to load            */
  MemDirSize    *length,     /**< Location for receiving length       */
  GError       **error       /**< Location for receiving errors       */
) G_GNUC_WARN_UNUSED_RESULT NONNULL((1));

/** Finish with memory from memdir_load() or memdir_alloc()
 *
 *  @return
 *    TRUE on success, FALSE on error.  
 */
gboolean memdir_unref(
  MemDir     *md,   /**< The MemDir the data is from.  */
  void       *data, /**< Pointer to the data           */
  GError    **error /**< Location for receiving errors */
) NONNULL((1,2));

/** Call memdir_unref() on a pointer and set it to NULL. */
#define MEMDIR_UNREF0(md,data,error) \
  G_STMT_START {                             \
    memdir_unref( md, data, error );         \
    (data) = NULL;                           \
  } G_STMT_END

/** Free memory in map, allowing it to be reused
 *
 *  @return
 *    TRUE on success, FALSE on error
 */
gboolean memdir_free(
  MemDir *md,    /**< The MemDir the data is from   */
  void *data,    /**< Pointer to the data           */
  GError **error /**< Location for receiving errors */
) NONNULL((1,2));

/** Call memdir_free() on a pointer and set it to NULL. */
#define MEMDIR_FREE0(md,data,error) \
  G_STMT_START {                            \
    memdir_free( md, data, error );         \
    (data) = NULL;                          \
  } G_STMT_END

/** Close a MemDir. Any pointers previously returned by \c memdir_load() or \c  
 *  memdir_alloc() will be invalidated.
 *
 *  @return
 *    TRUE on success, FALSE on failure
 */
gboolean memdir_close(
  MemDir     *md,   /**< An open MemDir                */
  GError    **error /**< Location for receiving errors */
) NONNULL((1));

/** Translate an absolute 64-bit offset into a MemDirPointer. For example, in
 *  a MemDir with 16-byte files, the offset 32 would map to file 2, offset 0.
 *  In a MemDir with 24-byte files, it'd map to file 1, offset 8.
 */
MemDirPointer memdir_offset_to_pointer(MemDir *md, guint64 offset);

/** Get an absolute 64-bit offset representing the current MemDir's size,
 *  counting freed/unused space within the MemDir but not at the end.
 */
guint64 memdir_current_offset(MemDir *md);

/** Get the current system page size */
long memdir_get_page_size();

#endif /* !_MEMDIR_H_ */
