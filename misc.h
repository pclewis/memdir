/** @file misc.h
 *  Miscellaneous macros/definitions.
 */

/*
 * Copyright (C) 2006 Philip Lewis <pcl@pclewis.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef _MEMDIR_MISC_H_
#define _MEMDIR_MISC_H_ 1

#include <sys/types.h>

/** @def GCC_VERSION
 *    Macro for easy checking of gcc version, equivalent to major version x 
 *    1000 + minor version, or -1 for non-gcc. Ex: gcc 2.09 = 2009
 */
#if defined(__GNUC__) && defined(__GNUC_MINOR__)
# ifndef GCC_VERSION
#   define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)
# endif  /* GCC_VERSION */
#else /* !__GNUC__ || !__GNUC_MINOR__ */
#   define GCC_VERSION -1
#endif /* !__GNUC__ || !__GNUC_MINOR__ */

/** @def UNUSED
 *    Suppress unused warning on argument and ensure it's not used.
 */
#if !defined(UNUSED)
# if (GCC_VERSION >= 2007)         /* GCC > 2.07 supports __attribute__ */
#   define UNUSED(x) x ## _UNUSED __attribute__((unused))
# elif defined(__LCLINT__)         /* lint */
#   define UNUSED(x) /*@unused@*/ UNUSED_ ## x
# elif defined(_MSC_VER)           /* Visual C++ */
#   define UNUSED(x) x ## _UNUSED     /* best we can do is turn off warning */
#   pragma warning( disable : 4100 )  /* unreferenced formal parameter */
# else                             /* Unknown */
#   define UNUSED(x) x ## _UNUSED     /* just rename the variable */
# endif /* compiler */
#endif /* !UNUSED */

/** @def NONNULL
 *    Expand to the nonnull attribute on gcc. From the gcc documentation: The 
 *    nonnull attribute specifies that some function parameters should be 
 *    non-null pointers. If the compiler determines that a null pointer is 
 *    passed in an argument slot marked as non-null, and the -Wnonnull option 
 *    is enabled, a warning is issued. The compiler may also choose to make 
 *    optimizations based on the knowledge that certain function arguments 
 *    will not be null.
 *
 *  @param arg
 *    The arg list for nonnull. Should be in double parenthesis, eg
 *    \c NONNULL((1,2))
 */
#if (GCC_VERSION >= 2007)
# define NONNULL(arg) __attribute__((nonnull arg))
#else
# define NONNULL(arg)
#endif

/** Assign value to field, freeing field first if it's not NULL. */
#define SET(field, value)   \
  G_STMT_START {            \
    if ( (field) != NULL )  \
      g_free(field);        \
    (field) = (value);      \
  } G_STMT_END

/** Free a pointer and set it to NULL */
#define FREE_AND_NULL(v) \
  G_STMT_START {         \
    g_free(v);           \
    v = NULL;            \
  } G_STMT_END

/** Round \p value up to the next multiple of \p step */
#define ROUND_UP(value, step) \
  ( (((value)+((step)-1)) / (step)) * (step) )

/** Round \p value down to the previous multiple of \p step */
#define ROUND_DOWN(value, step) \
  ( ((value) / (step)) * (step) )

/** Determine if a file exists */
gboolean file_exists(gchar *path);

/** Determine if a file is readable */
gboolean file_readable(gchar *path);

/** Determine if a file is writeable */
gboolean file_writeable(gchar *path);

/** Recursively remove a directory and all its contents */
gboolean rmrf(gchar *path);

/** Decode a urlencoded string. Caller must free. Invalid sequences are
 *  unmodified (the Right Thing to do is probably return Bad Request).
 *
 *  @param str          the urlencoded string
 *  @param result_size  if not NULL, size of result is placed here. the
 *                      terminating "\0" is not counted.
 */
gchar *urldecode(const gchar *str, gint *result_size)
  NONNULL((1));

guint hash_int64( gconstpointer p );

gboolean equal_int64( gconstpointer a, gconstpointer b );

guint hash_message( gconstpointer p );

gboolean equal_message( gconstpointer a, gconstpointer b );

/** Safely compare two strings. Either argument may be NULL. NULL is
 *  considered to be equal to NULL and less than everything else.
 *  @return -1 if l < r, 0 if l == r, 1 if l > r
 */
int safe_strcmp( const char *l, const char *r );

/** Error codes */
typedef enum {
  MISC_ERROR_OPEN,            /**< Error when opening file             */
  MISC_ERROR_CLOSE,           /**< Error when closing file             */
  MISC_ERROR_SEEK,            /**< Error when seeking in file          */
  MISC_ERROR_READ,            /**< Error when reading from file        */
  MISC_ERROR_EOF,             /**< Read fewer bytes than expected      */
  MISC_ERROR_WRITE,           /**< Error when writing to file          */
  MISC_ERROR_DISK_SPACE       /**< Out of disk space                   */
} MiscError;

/** Error domain for misc operations. Errors in this domain will be from
 *  the MiscError enum. */
#define MISC_ERROR g_quark_from_string("Misc")

/** Same as lseek(2), but sets error on failure. Additionally, if the 
 *  resulting offset of a SEEK_SET call is not the requested offset, error is 
 *  set and -1 is returned.
 *
 *  @return
 *    The new file offset on success, or -1 on error.
 */
off_t safe_lseek( int fd, off_t offset, int whence, GError **error );

/** same as write(2), but sets error on failure */
ssize_t safe_write( int fd, const void *buf, size_t count, GError **error );

/** same as read(2), but sets error on failure */
ssize_t safe_read( int fd, void *buf, size_t count, GError **error );

/** same as g_open(), but sets error on failure */
int safe_open( const gchar *filename, gint flags, gint mode, GError **error )
  NONNULL((1));

#endif /* !_MEMDIR_MISC_H_ */
