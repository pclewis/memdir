/** @file memdir.c
 *  MemDir implementation.
 */

/*
 * Copyright (C) 2007 Philip Lewis <pcl@pclewis.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/****************************************************************************/
/* Includes {{{1 ************************************************************/

/* compatibility stuff - must come first */
#include "compat.h"

#ifdef WIN32
#include <io.h>     /* lseek and friends */
#else /* !WIN32 */
#include <sys/mman.h>    /* mmap             */
#include <unistd.h>      /* sysconf          */
#endif /* WIN32 */

#include <sys/types.h>   /* types            */
#include <fcntl.h>       /* O_*              */
#include <errno.h>       /* errno            */
#include <string.h>      /* memcmp           */
#include <stdlib.h>      /* atoi             */
#include <glib.h>
#include <glib/gstdio.h> /* file functions   */
#include "misc.h"
#include "memdir.h"

#if UNITTEST
#include <stdio.h>       /* fileno           */
#include "test.h"
#endif

/************************************************************ }}}1 Includes */
/* Constants {{{1 ***********************************************************/

/** Domain for log messages */
#undef  G_LOG_DOMAIN
#define G_LOG_DOMAIN            "MemDir"

/** Prefix for memdir files */
#define MEMDIR_FILENAME_PREFIX  "memdir"

/** Format for data files */
#define MEMDIR_FILENAME_FORMAT  MEMDIR_FILENAME_PREFIX "_" "%03d" ".bin"

/** Info filename */
#define MEMDIR_FILENAME_INFO    MEMDIR_FILENAME_PREFIX ".ini"

/** Max number of files a memdir can contain */
#define MEMDIR_MAX_FILES        64    /* 64*(1<<31) = 128gb */

/** Version of memdir info file */
#define MEMDIR_INFO_VERSION     3

/** signed sizeof to prevent signed/unsigned warnings */
#define SSIZEOF(x) ((signed)(sizeof(x)))

/*********************************************************** }}}1 Constants */
/* Structures {{{1 **********************************************************/
/* MemDirChunk                                                         {{{2 */
/** A chunk */
typedef struct {
  gchar        *real_base;    /**< address where mmap starts (may be before 
                                the actual chunk data due to page size 
                                contraints) */
  gchar        *base;         /**< the base address                   */
  gchar        *cur;          /**< pointer to free space              */
  gchar        *end;          /**< pointer to end of chunk            */
  MemDirSize   free;          /**< bytes of free space remaining      */
  guint         ref_count;    /**< reference count                    */
  MemDir       *md;           /**< memdir this chunk belongs to       */
  MemDirPointer start;        /**< where chunk starts in the memdir   */
#ifdef WIN32
  HANDLE        map_handle;   /**< win32 map handle                   */
#endif
} MemDirChunk;

/* MemDirAlloc                                                         {{{2 */
/** An outstanding alloc */
typedef struct {
  void         *data;      /**< pointer to data                */
  MemDirChunk  *chunk;     /**< chunk that owns data           */
  MemDirPointer start;     /**< start of alloc (after size)    */
  MemDirSize    length;    /**< length of alloc (without size) */
  guint         ref_count; /**< reference count                */
} MemDirAlloc;

/* MemDirFreeSpace                                                     {{{2 */
/** A free area */
typedef struct {
  MemDirPointer start;  /**< where the free space starts */
  MemDirSize    length; /**< the length                  */
} MemDirFreeSpace;

/* MemDirFile                                                          {{{2 */
/** Info about a file in a memdir */
typedef struct {
#ifdef WIN32
  HANDLE          handle;    /**< HANDLE returned by CreateFileMapping */
#endif
  gint            fd;        /**< Open file descriptor (-1 = not open) */
  guint           ref_count;
} MemDirFile;

/* MemDir_                                                             {{{2 */
/** A MemDir */
struct MemDir_ {
  MemDirFile      files[MEMDIR_MAX_FILES];
  gchar          *path;             /**< full path to memdir files      */
  MemDirSize      chunk_size;       /**< size of a chunk                */
  guint           file_size;        /**< size of a file                 */
  guint           alignment;        /**< bytes to align allocs to       */
  MemDirPointer   next_pointer;     /**< next available pointer         */
  MemDirChunk    *cur_chunk;        /**< last mmap'd chunk              */
  GHashTable     *allocs;           /**< addr => chunk map              */
  GHashTable     *chunks;           /**< start => chunk map             */
  GList          *free_spaces;      /**< freed space, sorted by len     */
};

/********************************************************** }}}1 Structures */
/* Static Function Declarations {{{1 ****************************************/
/* MemDirChunk function declarations                                   {{{2 */
static void memdir_chunk_free(MemDirChunk *chunk)
  NONNULL((1))
  ;

static void memdir_chunk_free_fe( gpointer UNUSED(key), gpointer value,
                                  gpointer userdata )
  NONNULL((2,3))
  ;

static MemDirChunk *memdir_chunk_open( MemDir *md, MemDirPointer chunk_start,
                                       GError **error )
  G_GNUC_WARN_UNUSED_RESULT
  NONNULL((1))
  ;

static void memdir_chunk_unref(MemDirChunk *chunk)
  NONNULL((1))
  ;

static void memdir_chunk_unref_cur(MemDir *md)
  NONNULL((1))
  ;

/* MemDirAlloc function declarations                                   {{{2 */
static void memdir_alloc_add( MemDir *md, MemDirChunk *chunk,
                              MemDirPointer start, MemDirSize length,
                              gpointer data )
  NONNULL((1,2))
  ;

static void memdir_alloc_free(gpointer data)
  NONNULL((1))
  ;

/* MemDirFreeSpace function declaratoins                               {{{2 */
static gint memdir_free_space_find_by_size(gconstpointer a, gconstpointer b)
  G_GNUC_WARN_UNUSED_RESULT
  NONNULL((1))
  ;

static gint memdir_free_space_find_by_start(gconstpointer a, gconstpointer b)
  G_GNUC_WARN_UNUSED_RESULT
  NONNULL((1,2))
  ;

static gboolean memdir_free_space_add( MemDir *md, guint32 file_number,
                                       guint32 file_offset, MemDirSize length,
                                       gboolean merge )
  NONNULL((1))
  ;

static gboolean memdir_free_space_remove( MemDir *md, guint32 file_number,
                                          guint32 file_offset )
  NONNULL((1))
  ;

static void memdir_free_space_merge( MemDirChunk *chunk )
  NONNULL((1))
  ;

static void memdir_free_space_free(gpointer data, gpointer UNUSED(user_data))
  NONNULL((1))
  ;

static gboolean memdir_extend_file( int fd, off_t length, GError **error )
  G_GNUC_WARN_UNUSED_RESULT
  ;

/* MemDirFile function declarations                                    {{{2 */
static void memdir_close_file_number( MemDir *md, guint file_number )
  NONNULL((1))
  ;

static gboolean memdir_open_file_number( MemDir *md, guint file_number,
                                         GError **error )
  G_GNUC_WARN_UNUSED_RESULT
  NONNULL((1))
  ;

/* MemDirPointer function declarations                                 {{{2 */
static guint memdir_pointer_hash( gconstpointer data )
  NONNULL((1))
  ;

static gboolean memdir_pointer_equal( gconstpointer a, gconstpointer b )
  NONNULL((1,2))
  ;

/**************************************** }}}1 Static Function Declarations */
/* Test Setup {{{1 **********************************************************/

#if UNITTEST

#define MEMDIR_TEST_DIR "__test_memdir__"

static GError *test_error      = NULL;
static gchar  *test_path       = NULL;

/* setup mock functions {{{ */

TEST_MOCK( int, safe_open,
           (const gchar *filename, gint flags, gint mode, GError **error),
           (filename, flags, mode, error) );
#define safe_open test_mock_safe_open

TEST_MOCK( int, g_mkdir, (const gchar *path, int mode),
           (path, mode) );
#undef g_mkdir
#define g_mkdir test_mock_g_mkdir

TEST_MOCK( FILE *, g_fopen, (const gchar *filename, const gchar *mode),
           (filename,mode) );
#undef g_fopen
#define g_fopen test_mock_g_fopen

/* }}} */

static void
test_dir_setup()
{
  gboolean  result = FALSE;

  /* create dir for test */
  g_assert( test_path == NULL );
  test_path = g_build_path( G_DIR_SEPARATOR_S, MEMDIR_TEST_DIR, NULL );
  result    = (g_mkdir( test_path, S_IRWXU ) == 0);

  if ( !result ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_ERROR,
           "couldn't not create directory %s: %s",
           test_path, g_strerror(errno) );
  }
}

static void
test_dir_teardown()
{
  /* remove test dir */
  if ( !rmrf( test_path ) ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_ERROR,
           "could not remove dir `%s': %s",
           test_path, g_strerror(errno) );
  }
  g_free(test_path);
  test_path = NULL;

  test_error = NULL;
}

#endif /* UNITTEST */

/********************************************************** }}}1 Test Setup */
/* MemDirChunk functions {{{1 ***********************************************/
/* memdir_chunk_free()                                                 {{{2 */
/** Free a chunk */
static void
memdir_chunk_free(MemDirChunk *chunk)
{
  g_assert( chunk            != NULL );
  g_assert( chunk->md        != NULL );
  g_assert( chunk->real_base != NULL );

#ifdef WIN32
  UnmapViewOfFile( chunk->real_base );
#else /* !WIN32 */
  /* unmap */
  munmap( chunk->real_base, chunk->end - chunk->real_base);
#endif /* !WIN32 */

  /* TODO: this should probably be in its own function {{{ */
  /* decrease file ref count */
  chunk->md->files[ chunk->start.file_number ].ref_count -= 1;

  /* close file if it's no longer in use */
  if ( chunk->md->files[ chunk->start.file_number ].ref_count == 0 ) {
    memdir_close_file_number( chunk->md, chunk->start.file_number );
  }
  /* }}} */

  /* free memory */
  g_slice_free( MemDirChunk, chunk );
}

/* memdir_chunk_free_fe()                                              {{{2 */
/** Free a chunk, to be called from g_hash_table_foreach().
 *  @param userdata Pointer to GSList pointer for tracking freed chunks 
 */
static void
memdir_chunk_free_fe(gpointer UNUSED(key), gpointer value, gpointer userdata)
{
  MemDirChunk     *mdc          = value;
  GSList         **freed_chunks = userdata;

  g_assert( mdc          != NULL );
  g_assert( freed_chunks != NULL );

  /* see if we already freed it */
  if ( g_slist_find(*freed_chunks, mdc) != NULL )
    return;

  /* free the data */
  memdir_chunk_free( mdc );

  /* add to list */
  *freed_chunks = g_slist_prepend( *freed_chunks, mdc );
}

/* memdir_chunk_open()                                                 {{{2 */
/** Open a chunk specified by its starting location */
static MemDirChunk *
memdir_chunk_open( MemDir *md, MemDirPointer chunk_start, GError **error )
{
  MemDirChunk *chunk       = NULL;
  guint        offset      = 0;
  guint        offset_diff = 0;
  glong        page_size   = -1;

  g_assert( md    != NULL );
  g_assert( error == NULL || *error == NULL);

  /* offset should be a multiple of chunk size */
  g_assert( chunk_start.file_offset % md->chunk_size == 0 );
  g_assert( chunk_start.file_number < MEMDIR_MAX_FILES );

  /* see if it's already open */
  chunk = g_hash_table_lookup( md->chunks, &chunk_start );

  if ( chunk != NULL ) {
    chunk->ref_count += 1;
    return chunk;
  }

  /* make sure the file is open */
  if ( memdir_open_file_number(md, chunk_start.file_number, error) != TRUE )
    goto error;

  /* make sure the file is big enough */
  if ( memdir_extend_file(md->files[chunk_start.file_number].fd,
                          chunk_start.file_offset + md->chunk_size,
                          error) != TRUE ) {
    goto error;
  }

  /* start offset must be a multiple of the system page size */
  page_size   = memdir_get_page_size();
  offset      = ROUND_DOWN( chunk_start.file_offset, page_size );
  g_assert( offset <= chunk_start.file_offset );
  offset_diff = chunk_start.file_offset - offset;

  /* alloc a chunk struct */
  chunk = g_slice_new0(MemDirChunk);

  chunk->md        = md;
  chunk->start     = chunk_start;
  chunk->ref_count = 1;

#ifdef WIN32
  chunk->real_base = MapViewOfFile(md->files[chunk_start.file_number].handle,
                                   FILE_MAP_WRITE, 0, offset,
                                   md->chunk_size + offset_diff );

  if ( chunk->real_base == NULL ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_MMAP,
                 "MapViewOfFile failed: %s",
                 g_win32_error_message(GetLastError()) );
    goto error;
  }
#else /* !WIN32 */
  /* map it */
  chunk->real_base = mmap( 0,
                           md->chunk_size + offset_diff,
                           PROT_READ|PROT_WRITE,
                           MAP_SHARED,
                           md->files[chunk_start.file_number].fd,
                           offset );

  if ( chunk->real_base == MAP_FAILED ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_MMAP,
                 "mmap on file %d, offset %d: %s",
                 chunk_start.file_number,
                 chunk_start.file_offset,
                 g_strerror(errno) );
    goto error;
  }
#endif /* !WIN32 */

  chunk->base   = chunk->real_base + offset_diff;
  chunk->cur    = NULL;
  chunk->free   = 0;
  chunk->end    = chunk->base + md->chunk_size;

  /* add to hash */
  g_hash_table_insert( md->chunks, &chunk->start, chunk );

  return chunk;

error:
  if ( chunk != NULL )
    g_slice_free( MemDirChunk, chunk );
  return NULL;
}

/* memdir_chunk_close()                                                {{{2 */
/** Close a chunk (free, remove references) */
static void
memdir_chunk_close(MemDirChunk *chunk)
{
  gboolean result = FALSE;
  g_assert( chunk     != NULL );
  g_assert( chunk->md != NULL );
  g_assert( chunk     != chunk->md->cur_chunk );
  if ( chunk == chunk->md->cur_chunk ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
           "attempt to close cur_chunk! ignoring and adding reference" );
    chunk->ref_count += 1;
    return;
  }
  result = g_hash_table_remove( chunk->md->chunks, &chunk->start );
  g_assert( result );
  memdir_chunk_free( chunk );
}

/* memdir_chunk_unref()                                                {{{2 */
/** Remove reference to chunk, and close it if there are no more */
static void
memdir_chunk_unref(MemDirChunk *chunk)
{
  g_assert( chunk != NULL );
  g_assert( chunk->ref_count != 0 );
  if ( chunk->ref_count == 0 ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
           "unreferencing chunk with 0 references %d_%d",
           chunk->start.file_number, chunk->start.file_offset );
  } else {
    chunk->ref_count -= 1;
  }

  /* close if no more references */
  if ( chunk->ref_count == 0 )
    memdir_chunk_close(chunk);
}

/* memdir_chunk_unref_cur()                                            {{{2 */
/** Remove reference to md->cur_chunk, and set md->cur_chunk to NULL */
static void
memdir_chunk_unref_cur(MemDir *md)
{
  MemDirChunk *chunk = NULL;
  g_assert( md != NULL );
  g_assert( md->cur_chunk != NULL );

  chunk = md->cur_chunk;
  md->cur_chunk = NULL;
  memdir_chunk_unref(chunk);
}

/* memdir_mmap_next_chunk()                                            {{{2 */
/** Open the next mmap chunk */
static gboolean
memdir_mmap_next_chunk( MemDir *md, GError **error )
{
  MemDirChunk   *chunk       = NULL;
  MemDirPointer  start;

  g_assert( md    != NULL );
  g_assert( error == NULL || *error == NULL);

  start.file_number = md->next_pointer.file_number;

  /* first mapped chunk starts at the beginning of the chunk containing the 
   * current offset, extra chunks start a full chunk from the previous */
  if ( md->cur_chunk == NULL ) {
    start.file_offset = ROUND_DOWN(md->next_pointer.file_offset,
                                   md->chunk_size);
  } else {

    start.file_offset = md->cur_chunk->start.file_offset + md->chunk_size;

    /* not enough room in file for a full chunk, go to next file */
    if ( (start.file_offset + md->chunk_size) >= md->file_size ) {
      start.file_number += 1;
      start.file_offset  = 0;
    }

    memdir_chunk_unref_cur( md );
  }

  /* map the chunk */
  chunk = memdir_chunk_open(md, start, error);
  if ( chunk == NULL )
    return FALSE;

  /* if new chunk's offset is less than md's offset, start the appropriate 
   * distance in. this should only happen for the first chunk when opening an 
   * existing memdir */
  if ( chunk->start.file_number == md->next_pointer.file_number &&
       chunk->start.file_offset  < md->next_pointer.file_offset ) {
    g_assert( (chunk->start.file_offset + md->chunk_size) >
                                    md->next_pointer.file_offset );
    chunk->cur  = chunk->base +
                  (md->next_pointer.file_offset - chunk->start.file_offset);
    chunk->free = md->chunk_size - (chunk->cur - chunk->base);
    /* don't need to touch md->next_pointer */
  } else {
    chunk->cur       = chunk->base;
    chunk->free      = md->chunk_size;
    md->next_pointer = chunk->start;
  }

  chunk->end  = chunk->base + md->chunk_size;

  /* update the md */
  md->cur_chunk = chunk;

  return TRUE;
}

/*********************************************** }}}1 MemDirChunk functions */
/* MemDirAlloc functions {{{1 ***********************************************/
/* memdir_alloc_free()                                                 {{{2 */
/** Free a MemDirAlloc */
static void
memdir_alloc_free(gpointer data)
{
  g_assert( data != NULL );
  g_slice_free( MemDirAlloc, data );
}

/* memdir_alloc_add()                                                  {{{2 */
/** Track an allocation */
static void
memdir_alloc_add( MemDir *md, MemDirChunk *chunk, MemDirPointer start,
                  MemDirSize length, gpointer data )
{
  MemDirAlloc *mda = NULL;

  g_assert( md    != NULL );
  g_assert( chunk != NULL );
  g_assert( data  != NULL );

  /* see if it's already being tracked */
  mda = g_hash_table_lookup( md->allocs, data );

  if ( mda != NULL ) {
    /* increase ref count */
    mda->ref_count += 1;
  } else {
    /* new alloc */
    mda = g_slice_new0( MemDirAlloc );
    mda->data       = data;
    mda->chunk      = chunk;
    mda->start      = start;
    mda->length     = length;
    mda->ref_count  = 1;
    g_hash_table_insert( md->allocs, data, mda );
  }
}

/*********************************************** }}}1 MemDirAlloc functions */
/* MemDirFreeSpace functions {{{1 *******************************************/
/* memdir_free_space_comp()                                            {{{2 */
static gint
memdir_free_space_comp( gconstpointer a, gconstpointer b )
{
  const MemDirFreeSpace *fa = a, *fb = b;
  g_assert( fa != NULL );
  g_assert( fb != NULL );
  if ( fa->length < fb->length )
    return -1;
  if ( fa->length > fb->length )
    return 1;
  return 0;
}

/* test_memdir_free_space_comp()                                       {{{2 */
#if UNITTEST
static TestResult
test_memdir_free_space_comp()
{
  MemDirFreeSpace a,b,c;
  a.length = 1;
  b.length = 2;
  c.length = 3;

  TEST_ASSERT( memdir_free_space_comp( &a, &b )  < 0 );
  TEST_ASSERT( memdir_free_space_comp( &b, &c )  < 0 );
  TEST_ASSERT( memdir_free_space_comp( &c, &a )  > 0 );
  TEST_ASSERT( memdir_free_space_comp( &c, &b )  > 0 );
  TEST_ASSERT( memdir_free_space_comp( &a, &a ) == 0 );

  TEST_DONE();
}
#endif /* UNITTEST */

/* memdir_free_space_free()                                            {{{2 */
/** Free a MemDirFreeSpace */
static void
memdir_free_space_free(gpointer data, gpointer UNUSED(user_data))
{
  g_assert( data != NULL );
  g_slice_free( MemDirFreeSpace, data );
}

/* memdir_free_space_find_by_size()                                    {{{2 */
/** Find a MemDirFreeSpace containing at least specified amount of space. The
 *  size needs to contain the exact amount, or enough to split off another
 *  chunk of free space.
 *
 *  @param a  Pointer to MemDirFreeSpace to check
 *  @param b  Int stored in pointer for desired amount of free space
 *
 *  @note
 *    To be called from g_list_find_custom()
 *
 *  @return
 *    zero if a->length == b
 *    zero if a->length >= (b+sizeof(MemDirSize))
 *    non-zero otherwise
 */
static gint
memdir_free_space_find_by_size(gconstpointer a, gconstpointer b)
{
  const MemDirFreeSpace *fs = a;
  g_assert( fs != NULL );
  if (fs->length == GPOINTER_TO_INT(b))
    return 0;
  if (fs->length >= (GPOINTER_TO_INT(b) + SSIZEOF(MemDirSize)))
    return 0;
  return 1;
}

/* test_memdir_free_space_find_by_size()                               {{{2 */
#if UNITTEST
static TestResult
test_memdir_free_space_find_by_size()
{
  GList           *list = NULL;
  GList           *r    = NULL;
#define NUM_FS 10
  MemDirFreeSpace  fs[NUM_FS];
  int              i    = -1;

  for ( i = 0; i < NUM_FS; ++i ) {
    /* init */
    fs[i].length = i;
    list = g_list_prepend(list, &fs[i]);

    /* make sure exact size matches */
    TEST_ASSERT_EQUAL_INT(
      memdir_free_space_find_by_size(&fs[i], GUINT_TO_POINTER(i)), 0
    );

    /* make sure size+1 doesn't match */
    TEST_ASSERT_OP_INT(
      memdir_free_space_find_by_size(&fs[i], GUINT_TO_POINTER(i+1)), !=, 0
    );

    /* make sure size-1 doesn't match (not enough room to split) */
    TEST_ASSERT_OP_INT(
      memdir_free_space_find_by_size(&fs[i], GUINT_TO_POINTER(i-1)), !=, 0
    );

    /* if big enough, make sure size-4 does match (enough room to split) */
    if ( i > (int)sizeof(guint32) ) {
      TEST_ASSERT_EQUAL_INT(
        memdir_free_space_find_by_size(&fs[i], GUINT_TO_POINTER(i-sizeof(guint32))), 0
      );
    }
  }

  /* reverse list to order by size */
  list = g_list_reverse(list);

  /* try it with g_list_find_custom */
  for ( i = 0; i < NUM_FS; ++i ) {
    r = g_list_find_custom( list, GUINT_TO_POINTER(i),
                            memdir_free_space_find_by_size );
    TEST_ASSERT_NOT_NULL( r );
    TEST_ASSERT( r->data == &fs[i] );
  }

  /* try search for non-existant entry */
  r = g_list_find_custom( list, GUINT_TO_POINTER(NUM_FS+1),
                          memdir_free_space_find_by_size );
  TEST_ASSERT_NULL( r );

  /* clean up */
  /* list items here are local, don't try to free them */
  g_list_free(list);
#undef NUM_FS

  TEST_DONE();
}
#endif /* UNITTEST */

/* memdir_free_space_find_by_start()                                   {{{2 */
/** Find a MemDirFreeSpace starting a specified offset
 *
 *  @param a  Pointer to MemDirFreeSpace to check
 *  @param b  Pointer to MemDirPointer to compare with
 *
 *  @note
 *    To be called from g_list_find_custom()
 *
 *  @return
 *    zero if a->start == b
 *    non-zero otherwise
 */
static gint
memdir_free_space_find_by_start(gconstpointer a, gconstpointer b)
{
  const MemDirFreeSpace *fs  = a;
  const MemDirPointer   *mdp = b;
  g_assert( fs  != NULL );
  g_assert( mdp != NULL );
  if (fs->start.file_number == mdp->file_number &&
      fs->start.file_offset == mdp->file_offset)
    return 0;
  return 1;
}

/* memdir_free_space_add()                                             {{{2 */
/** Add free space to a memdir
 *  @param md           MemDir to add free space to
 *  @param file_number  File free space is in
 *  @param file_offset  Offset free space (including size header) starts
 *  @param length       Length of free space (including size header)
 *  @param merge        if TRUE, merge free space in chunk after adding
 *  @note
 *    length must be > sizeof(MemDirSize) so that the length can be stored 
 *  @return
 *    TRUE on success
 */
static gboolean
memdir_free_space_add( MemDir *md, guint32 file_number, guint32 file_offset,
                       MemDirSize length, gboolean merge )
{
  MemDirPointer    mdp;
  MemDirFreeSpace *fs    = NULL;
  MemDirChunk     *chunk = NULL;
  gchar           *data  = NULL;
  GError          *error = NULL;

  g_assert( md          != NULL );
  g_assert( file_offset <  md->file_size );
  g_assert( length      >  4 );

  mdp.file_number = file_number;
  mdp.file_offset = ROUND_DOWN(file_offset, md->chunk_size);
  chunk           = memdir_chunk_open( md, mdp, &error );

  g_assert( chunk != NULL );

  if ( chunk == NULL ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
            "couldn't open chunk %d_%d to add free space: %s",
            file_number, file_offset, error->message );
    memdir_chunk_unref(chunk);
    return FALSE;
  }

  /* respect alignment unless at end */
  if ( file_offset + length < (unsigned)md->chunk_size )
    length = ROUND_UP( length, md->alignment );

  /* add room for size */
  length -= 4;

  /* write size (freespace is negative) */
  data = chunk->base + file_offset;
  *((MemDirSize*)data) = -length;

  fs                    = g_slice_new0( MemDirFreeSpace );
  fs->start.file_number = file_number;
  fs->start.file_offset = file_offset + 4;
  fs->length            = length;


  md->free_spaces = g_list_insert_sorted( md->free_spaces, fs,
                                          memdir_free_space_comp );

  if ( merge )
    memdir_free_space_merge( chunk );

  /* finish with chunk */
  memdir_chunk_unref(chunk);

  return TRUE;
}

/* memdir_free_space_remove()                                          {{{2 */
/** Remove free space from a memdir.
 *
 *  @return
 *    TRUE if space was found and removed
 *    FALSE otherwise
 */
static gboolean
memdir_free_space_remove( MemDir *md, guint32 file_number,
                          guint32 file_offset )
{
  GList         *lp  = NULL;
  MemDirPointer  mdp;

  g_assert( md != NULL );
  g_assert( file_offset < md->file_size );

  mdp.file_number = file_number;
  mdp.file_offset = file_offset;

  lp = g_list_find_custom( md->free_spaces, &mdp,
                            memdir_free_space_find_by_start );

  if ( lp == NULL )
    return FALSE;

  /* free the data */
  g_assert( lp->data != NULL );
  g_slice_free( MemDirFreeSpace, lp->data );

  /* remove from list */
  md->free_spaces = g_list_delete_link( md->free_spaces, lp );

  return TRUE;
}

/* memdir_free_space_load()                                            {{{2 */
static gboolean
memdir_free_space_load( GKeyFile *key_file, MemDir *md, GError **error )
{
  GError  *kf_error = NULL;
  gchar  **keys     = NULL;
  gchar  **key      = NULL;

  g_assert( key_file != NULL );
  g_assert( md       != NULL );
  g_assert( error    == NULL || *error == NULL);
  g_assert( md->free_spaces == NULL );

  keys = g_key_file_get_keys( key_file, "freespace", NULL, &kf_error );
  if ( kf_error != NULL ) {
    g_propagate_error( error, kf_error );
    return FALSE;
  }

  for ( key = keys; *key != NULL; ++key ) {
    MemDirFreeSpace *fs   = NULL;
    gchar           *number_s = NULL;
    gchar           *offset_s = NULL;

    g_assert( *key != NULL );

    /* split key ("1_1234") into number_offset */
    number_s = *key;
    offset_s = strchr( number_s, '_' );
    if ( offset_s != NULL )
      offset_s += 1; /* skip : */

    if ( offset_s == NULL ||
         !g_ascii_isdigit(*number_s) ||
         !g_ascii_isdigit(*offset_s) ) {
      g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_INVALID_INFO,
                   "invalid key in freespace group: %s", *key );
      goto error;
    }

    /* create free space info */
    fs = g_slice_new( MemDirFreeSpace );
    fs->start.file_number = atoi( number_s );
    fs->start.file_offset = atoi( offset_s );
    fs->length = g_key_file_get_integer( key_file, "freespace", *key,
                                         &kf_error );
    if ( kf_error != NULL ) {
      g_propagate_error( error, kf_error );
      g_slice_free( MemDirFreeSpace, fs );
      g_strfreev(keys);
      return FALSE;
    }

    /* add to list */
    md->free_spaces = g_list_prepend( md->free_spaces, fs );

  }

  /* free key list */
  g_strfreev(keys);

  /* sort free space list */
  md->free_spaces = g_list_sort( md->free_spaces, memdir_free_space_comp );

  return TRUE;

error:
  if ( kf_error != NULL )
    g_propagate_error( error, kf_error );
  if ( keys != NULL )
    g_strfreev(keys);
  if ( md->free_spaces != NULL ) {
    g_list_foreach( md->free_spaces, memdir_free_space_free, NULL );
    g_list_free( md->free_spaces );
    md->free_spaces = NULL;
  }
  return FALSE;
}

/* test_memdir_free_space_load()                                       {{{2 */
#if UNITTEST
static TestResult
test_memdir_free_space_load()
{
  gboolean         result  = FALSE;
  GKeyFile        *kf      = NULL;
  gchar            data1[] = "[freespace]\n0_03=3\n0_05=5\n1_12=2\n"
                             "1_16=6\n2_24=4\n0_01=1\n";
  gchar            data2[] = "[freespace]\n";
  gchar            data3[] = "[freespace]\ntest=invalid\n";
  GError          *error   = NULL;
  GList           *p       = NULL;
  MemDirFreeSpace *fs      = NULL;
  MemDir           md;

  /* try loading normal data */
  kf     = g_key_file_new();
  result = g_key_file_load_from_data( kf, data1, sizeof(data1),
                                      G_KEY_FILE_NONE, NULL );
  g_assert( result );

  md.free_spaces = NULL;
  result = memdir_free_space_load( kf, &md, &error );
  TEST_ASSERT_NO_ERROR( error );
  TEST_ASSERT( result );
  TEST_ASSERT_NOT_NULL( md.free_spaces );

  /* make sure it is loaded and sorted properly */
  p = md.free_spaces;

#define ASSERT_NEXT_FS_IS( e_file, e_offset, e_length )         \
  G_STMT_START {                                                \
    TEST_ASSERT_NOT_NULL( p );                                  \
    if ( p != NULL ) {                                          \
      fs = p->data;                                             \
      TEST_ASSERT_EQUAL_INT( fs->start.file_number, e_file );   \
      TEST_ASSERT_EQUAL_INT( fs->start.file_offset, e_offset ); \
      TEST_ASSERT_EQUAL_INT( fs->length, e_length );            \
      p = g_list_next(p);                                       \
    }                                                           \
  } G_STMT_END

  ASSERT_NEXT_FS_IS( 0,  1, 1 );
  ASSERT_NEXT_FS_IS( 1, 12, 2 );
  ASSERT_NEXT_FS_IS( 0,  3, 3 );
  ASSERT_NEXT_FS_IS( 2, 24, 4 );
  ASSERT_NEXT_FS_IS( 0,  5, 5 );
  ASSERT_NEXT_FS_IS( 1, 16, 6 );

#undef ASSERT_NEXT_FS_IS

  g_key_file_free( kf );
  kf = NULL;
  g_list_foreach( md.free_spaces, memdir_free_space_free, NULL );
  g_list_free( md.free_spaces );
  md.free_spaces = NULL;

  /* try no data */
  kf = g_key_file_new();
  result = g_key_file_load_from_data( kf, data2, sizeof(data2),
                                      G_KEY_FILE_NONE, NULL );
  g_assert( result );

  result = memdir_free_space_load( kf, &md, &error );
  TEST_ASSERT_NO_ERROR( error );
  TEST_ASSERT( result );
  TEST_ASSERT_NULL( md.free_spaces );

  g_key_file_free( kf );
  kf = NULL;
  if ( md.free_spaces != NULL ) {
    g_list_foreach( md.free_spaces, memdir_free_space_free, NULL );
    g_list_free( md.free_spaces );
    md.free_spaces = NULL;
  }

  /* try malformed data */
  kf = g_key_file_new();
  result = g_key_file_load_from_data( kf, data3, sizeof(data3),
                                      G_KEY_FILE_NONE, NULL );
  g_assert( result );

  result = memdir_free_space_load( kf, &md, &error );
  TEST_ASSERT_ANY_ERROR( error );
  TEST_ASSERT( !result );
  TEST_ASSERT_NULL( md.free_spaces );

  g_key_file_free( kf );
  kf = NULL;
  if ( md.free_spaces != NULL ) {
    g_list_foreach( md.free_spaces, memdir_free_space_free, NULL );
    g_list_free( md.free_spaces );
    md.free_spaces = NULL;
  }

  TEST_DONE();

}
#endif /* UNITTEST */

/* memdir_free_space_merge()                                           {{{2 */
/** Merge free spaces in a chunk */
static void
memdir_free_space_merge( MemDirChunk *chunk )
{
  MemDir        *md        = NULL;
  gchar         *p         = NULL;
  MemDirSize     size      = -1;
  MemDirSize     full_size = -1;
  MemDirPointer  mdp       = chunk->start;

  g_assert( chunk     != NULL );
  g_assert( chunk->md != NULL );

  md = chunk->md;

  for ( p = chunk->base; p < chunk->end; ) {
    /* First 4 bytes should be size */
    size = *((MemDirSize*)p);

    /* respect alignment */
    full_size = ROUND_UP(abs(size), md->alignment);

    /* Go to next alloc */
    p += full_size;

    if ( p >= chunk->end )
      break;

    /* Free space has negative size */
    while ( size < 0 ) {
      /* See if next alloc is free also */
      MemDirSize next_size      = *((MemDirSize*)p);
      MemDirSize next_full_size = ROUND_UP( abs(next_size), md->alignment );
      if ( next_size < 0 ) {
        MemDirPointer    next_mdp;
        MemDirFreeSpace *fs       = NULL;
        GList           *lp       = NULL;

        /* first remove old entries */
        next_mdp              = mdp;
        next_mdp.file_offset += full_size;

        /* FIXME: dup code */
        /* current block */
        lp = g_list_find_custom( md->free_spaces, &mdp,
                                 memdir_free_space_find_by_start );
        if ( lp == NULL ) {
          g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
                 "found untracked free space at %d_%d",
                 mdp.file_number, mdp.file_offset );
        } else {
          md->free_spaces = g_list_delete_link( md->free_spaces, lp );
        }

        /* next block */
        lp = g_list_find_custom( md->free_spaces, &next_mdp,
                                 memdir_free_space_find_by_start );
        if ( lp == NULL ) {
          g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
                 "found untracked free space at %d_%d",
                 next_mdp.file_number, next_mdp.file_offset );
        } else {
          md->free_spaces = g_list_delete_link( md->free_spaces, lp );
        }

        /* create new free space */
        memdir_free_space_add( md, mdp.file_number, mdp.file_offset,
                               full_size + next_full_size, FALSE );

        /* move to next block */
        mdp.file_offset += fs->length;
        p               += next_full_size;

        if ( p >= chunk->end )
          break;

      }

      mdp.file_offset += full_size;
    }
  }
}

/******************************************* }}}1 MemDirFreeSpace functions */
/* MemDirFile functions {{{1 ************************************************/
/* memdir_extend_file()                                                {{{2 */
/** Extend a file.
 *
 *  @return
 *    TRUE on success, FALSE on failure
 */
static gboolean
memdir_extend_file( int fd, off_t length, GError **error )
{
  off_t old_length = -1;
  off_t cur_length = -1;

  g_assert( fd     >= 0 );
  g_assert( length >  0 );
  g_assert( error  == NULL || *error == NULL );

  /* make sure the new length is really longer */
  old_length = safe_lseek( fd, 0, SEEK_END, error );
  if ( old_length == -1 )
    return FALSE;

  /* already big enough, nothing to do */
  if ( old_length >= length )
    return TRUE;

  /* no ftruncate() till POSIX 1003.1-1996 */
  /* seek to new length */
  cur_length = safe_lseek( fd, length-1, SEEK_SET, error );
  if ( cur_length != length-1 )
    return FALSE;

  /* write a NUL byte at the new position to actually extend the file */
  if ( safe_write( fd, "\0", 1, error ) != 1 )
    return FALSE;

  /* make sure the file is now the correct length */
  cur_length = safe_lseek( fd, 0, SEEK_END, error );
  if ( cur_length == -1 )
    return FALSE;

  if ( cur_length != length ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_RESIZE,
                 "tried to resize to %ld, but file is actually %ld",
                 (long)length, (long)cur_length );
    return FALSE;
  }

  return TRUE;
}

/* test_memdir_extend_file()                                           {{{2 */
#if UNITTEST
static TestResult
test_memdir_extend_file()
{
  gboolean  result     = FALSE;
  off_t     len        = -1;
  const int target_len = 100;

  g_assert( errno == 0 );

  /* extend test file */
  result = memdir_extend_file( test_temp_fd, target_len, &test_error );
  TEST_ASSERT( result == TRUE );
  TEST_ASSERT_NO_ERROR( test_error );

  /* make sure it worked */
  len = lseek( test_temp_fd, 0, SEEK_END );
  TEST_ASSERT_EQUAL_INT( len, target_len );

  /* try extending it smaller than it already is */
  result = memdir_extend_file( test_temp_fd, target_len - 1, &test_error );
  TEST_ASSERT( result == TRUE );
  TEST_ASSERT_NO_ERROR( test_error );

  /* make sure it's right */
  len = lseek( test_temp_fd, 0, SEEK_END );
  TEST_ASSERT_EQUAL_INT( len, target_len );

  g_assert( errno == 0 );

  TEST_DONE();
}
#endif /* UNITTEST */

/* memdir_close_file_number()                                          {{{2 */
/** Close a given file number in a memdir. */
static void
memdir_close_file_number( MemDir *md, guint file_number )
{
  MemDirFile *file = NULL;

  g_assert( md != NULL );

  file = &md->files[file_number];

  /* make sure it isn't referenced */
  g_assert( file->ref_count == 0 );
  if ( file->ref_count != 0 ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
           "%s: closing file number %d which still has %d refs!",
           md->path, file_number, file->ref_count );
    file->ref_count = 0;
  }

#ifdef WIN32
  /* close mapping handle */
  g_assert( file->handle != NULL );
  CloseHandle( file->handle );
  file->handle = NULL;
#endif /* WIN32 */

  /* close file */
  g_assert( file->fd >= 0 );
  close( file->fd );
  file->fd = -1;
}

/* memdir_open_file_number()                                           {{{2 */
/** Ensure that a given file number in a memdir is open and increase
 *  its reference count.
 *
 *  @return TRUE on success */
static gboolean
memdir_open_file_number( MemDir *md, guint file_number, GError **error )
{
  gchar      *filename = NULL;
  gchar      *fullpath = NULL;
  MemDirFile *file     = NULL;

  g_assert( md != NULL );
  g_assert( file_number < MEMDIR_MAX_FILES );
  g_assert( error == NULL || *error == NULL );

  file = &md->files[file_number];

  file->ref_count += 1;

  /* already open */
  if ( file->fd >= 0 )
    return TRUE;

  /* if not already open, we should be the only ref */
  g_assert( file->ref_count == 1 );

  /* build path to file */
  filename = g_strdup_printf( MEMDIR_FILENAME_FORMAT, file_number );
  fullpath = g_build_filename( md->path, filename, NULL );

  g_free(filename);
  filename = NULL;

  /* open it */
  file->fd = safe_open( fullpath, O_CREAT|O_RDWR, S_IRUSR|S_IWUSR, error );

  g_free(fullpath);
  fullpath = NULL;

  if ( file->fd < 0 ) {
    file->ref_count = 0;
    return FALSE;
  }

#ifdef WIN32
  file->handle = CreateFileMapping(
    (HANDLE)_get_osfhandle(file->fd),
    NULL, PAGE_READWRITE|SEC_COMMIT,
    0, md->file_size, NULL
  );

  if ( file->handle == NULL ) {
    close(file->fd);
    file->ref_count = 0;
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_OPEN,
                 "CreateFileMapping failed: %s",
                 g_win32_error_message(GetLastError()) );
    return FALSE;
  }
#endif

  return TRUE;
}

/* test_memdir_open_file_number()                                      {{{2 */
#if UNITTEST
static TestResult
test_memdir_open_file_number()
{
  gboolean result = FALSE;
  int      i      = -1;
  int      fd     = -1;
  gchar   *name   = NULL;
  gchar   *path   = NULL;
  GError  *error  = NULL;
  MemDir   md;

  md.file_size = 32;
  md.path      = test_path;

  /* setup fds */
  for ( i = 0; i < MEMDIR_MAX_FILES; ++i ) {
    md.files[i].fd        = -1;
    md.files[i].ref_count =  0;
  }

  /* open a file */
  result = memdir_open_file_number( &md, 0, &error );
  TEST_ASSERT_NO_ERROR( error );
  TEST_ASSERT( result );
  TEST_ASSERT_OP_INT( md.files[0].fd, >=, 0 );
  TEST_ASSERT_OP_INT( md.files[0].fd, !=, fileno(stdin)  );
  TEST_ASSERT_OP_INT( md.files[0].fd, !=, fileno(stdout) );
  TEST_ASSERT_OP_INT( md.files[0].fd, !=, fileno(stderr) );
  TEST_ASSERT_EQUAL_INT( md.files[0].ref_count, 1 );

  /* make sure file exists */
  name = g_strdup_printf( MEMDIR_FILENAME_FORMAT, 0 );
  path = g_build_filename( test_path, name, NULL );
  g_free(name);
  TEST_ASSERT( g_file_test(path, G_FILE_TEST_EXISTS) );
  g_free(path);

  /* open it again */
  fd = md.files[0].fd;
  result = memdir_open_file_number( &md, 0, &error );
  TEST_ASSERT_NO_ERROR( error );
  TEST_ASSERT( result );
  TEST_ASSERT_EQUAL_INT( md.files[0].fd, fd );
  TEST_ASSERT_EQUAL_INT( md.files[0].ref_count, 2 );

  /* close it */
  md.files[0].ref_count = 0;
  memdir_close_file_number( &md, 0 );
  TEST_ASSERT_OP_INT( md.files[0].fd, !=, fd );

  /* try failed open */
  test_set_mock_return_safe_open( -1 );
  result = memdir_open_file_number( &md, 2, &error );
  /* since we're mocking the function that'd set an error, we can't make sure
   * it's set */
  /* TEST_ASSERT_ANY_ERROR( error ); */
  TEST_ASSERT( !result );
  TEST_ASSERT_EQUAL_INT( md.files[2].fd, -1 );
  if ( md.files[2].fd != -1 ) {
    md.files[2].ref_count = 0;
    memdir_close_file_number( &md, 2 );
  }
  TEST_ASSERT_EQUAL_INT( md.files[2].ref_count, 0 );

  /* make sure file does not exist */
  name = g_strdup_printf( MEMDIR_FILENAME_FORMAT, 2 );
  path = g_build_filename( test_path, name, NULL );
  g_free(name);
  TEST_ASSERT( !g_file_test(path, G_FILE_TEST_EXISTS) );
  g_free(path);

  TEST_DONE();
}
#endif /* UNITTEST */

/************************************************ }}}1 MemDirFile functions */
/* MemDirPointer functions {{{1 *********************************************/
/* memdir_pointer_hash()                                               {{{2 */
static guint
memdir_pointer_hash( gconstpointer data )
{
  const MemDirPointer *ptr = data;
  g_assert( ptr != NULL );
  return ptr->file_offset;
}

/* memdir_pointer_equal()                                              {{{2 */
static gboolean
memdir_pointer_equal( gconstpointer a, gconstpointer b )
{
  const MemDirPointer *pa = a, *pb = b;
  g_assert( pa != NULL );
  g_assert( pb != NULL );
  return (pa->file_number == pb->file_number) &&
         (pa->file_offset == pb->file_offset);
}

/* test_memdir_pointer_equal()                                         {{{2 */
#if UNITTEST
static TestResult
test_memdir_pointer_equal()
{
  MemDirPointer a = {0,0}, b = {1,0}, c = {0,1}, d = {0,0};

  TEST_ASSERT( memdir_pointer_equal(&a, &b) != TRUE );
  TEST_ASSERT( memdir_pointer_equal(&b, &c) != TRUE );
  TEST_ASSERT( memdir_pointer_equal(&c, &d) != TRUE );
  TEST_ASSERT( memdir_pointer_equal(&a, &a) == TRUE );

  TEST_DONE();
}
#endif /* UNITTEST */

/****************************************************************************/
/****************************************************************************/

/********************************************* }}}1 MemDirPointer functions */
/* MemDir functions {{{1 ****************************************************/
/* memdir_struct_new()                                                 {{{2 */
/** Allocate and return a new MemDir struct */
static MemDir *
memdir_struct_new()
{
  MemDir    *md = NULL;
  int        i  = 0;

  /* allocate */
  md = g_slice_new0(MemDir);

  /* invalid file pointers, 0 references */
  for ( i = 0; i < MEMDIR_MAX_FILES; ++i ) {
    md->files[i].fd        = -1;
    md->files[i].ref_count = 0;
#ifdef WIN32
    md->files[i].handle    = NULL;
#endif /* WIN32 */
  }

  /* create hash tables */
  md->allocs = g_hash_table_new_full( g_direct_hash, g_direct_equal,
                                      NULL, memdir_alloc_free );
  md->chunks = g_hash_table_new( memdir_pointer_hash, memdir_pointer_equal );

  md->free_spaces = NULL;

  return md;
}

/* memdir_struct_free()                                                {{{2 */
/** Free a MemDir struct */
static void
memdir_struct_free(MemDir *md)
{
  int     i            = 0;
  GSList *freed_chunks = NULL;

  g_assert( md != NULL );

  memdir_chunk_unref_cur( md );

  /* free chunks hash table */
  if ( md->chunks != NULL ) {
    g_hash_table_foreach( md->chunks, memdir_chunk_free_fe, &freed_chunks );
    g_hash_table_destroy( md->chunks );
  }

  /* free allocs hash table */
  g_hash_table_destroy( md->allocs );

  /* free freed-chunks list */
  g_slist_free(freed_chunks);

  /* free free-space list */
  g_list_foreach( md->free_spaces, memdir_free_space_free, NULL );
  g_list_free( md->free_spaces );

  /* close files */
  for ( i = 0; i < MEMDIR_MAX_FILES; ++i )
    if ( md->files[i].fd >= 0 )
      memdir_close_file_number( md, i );

  /* free path */
  g_free( md->path );

  /* free the memdir */
  g_slice_free( MemDir, md );

}

/**************************************************** }}}1 MemDir functions */
/* Misc Functions {{{1 ******************************************************/
/* memdir_write_info()                                                 {{{2 */
gboolean
memdir_write_info( const gchar *path, MemDir *md, GError **error )
{
  gchar    *name   = NULL;
  FILE     *fp     = NULL;

  g_assert( path  != NULL );
  g_assert( md    != NULL );
  g_assert( error == NULL || *error == NULL);

  name = g_build_filename( path, MEMDIR_FILENAME_INFO, NULL );
  g_assert(name != NULL);

  fp = g_fopen( name, "w" );
  g_free(name);

  if ( fp == NULL ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_OPEN,
                 g_strerror(errno) );
    return FALSE;
  }

  fprintf( fp, "[memdir]\n" );

  /* version info */
  fprintf( fp, "version=%d\n", MEMDIR_INFO_VERSION );

  /* size info */
  fprintf( fp, "chunk_size=%d\n", md->chunk_size );
  fprintf( fp, "file_size=%d\n", md->file_size );
  fprintf( fp, "alignment=%d\n", md->alignment );

  /* next pointer */
  fprintf( fp, "file=%d\n", md->next_pointer.file_number );
  fprintf( fp, "offset=%d\n", md->next_pointer.file_offset );

  /* add free space info if present */
  if ( md && md->free_spaces != NULL ) {
    GList *p = NULL;
    fprintf( fp, "\n[freespace]\n" );
    for ( p = md->free_spaces; p != NULL; p = g_list_next(p) ) {
      MemDirFreeSpace *fs = p->data;
      fprintf( fp, "%d_%d=%d\n", fs->start.file_number,
                                 fs->start.file_offset,
                                 fs->length );
    }
  }

  fclose( fp );

  return TRUE;
}

/* test_memdir_write_info()                                            {{{2 */
#if UNITTEST
static TestResult
test_memdir_write_info()
{
  GError        *error      = NULL;
  gboolean       result     = FALSE;
  GKeyFile      *key_file   = NULL;
  gchar         *info_fname = NULL;
  MemDir         md;

  /* write some info */
  md.next_pointer.file_number = 123;
  md.next_pointer.file_offset = 456;
  md.free_spaces              = NULL;
  result = memdir_write_info( test_path, &md, &error );
  TEST_ASSERT_NO_ERROR( error );
  TEST_ASSERT( result );

  /* read it back */
  key_file = g_key_file_new();

  info_fname = g_build_filename( test_path, MEMDIR_FILENAME_INFO, NULL );
  result = g_key_file_load_from_file( key_file, info_fname,
                                      G_KEY_FILE_NONE, &error );
  g_free( info_fname ); info_fname = NULL;
  TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );
  TEST_REQUIRE( TEST_ASSERT( result ) );

  /* make sure values match */
  TEST_ASSERT_EQUAL_INT(
    md.next_pointer.file_number,
    g_key_file_get_integer( key_file, "memdir", "file", &error );
  );
  TEST_ASSERT_NO_ERROR( error );

  TEST_ASSERT_EQUAL_INT(
    md.next_pointer.file_offset,
    g_key_file_get_integer( key_file, "memdir", "offset", &error );
  );
  TEST_ASSERT_NO_ERROR( error );

  /* try failed open */
  test_set_mock_return_g_fopen( NULL );
  test_set_mock_errno_g_fopen( EACCES );
  result = memdir_write_info( test_path, &md, &error );
  TEST_ASSERT_ANY_ERROR( error );
  TEST_ASSERT( !result );

  TEST_DONE_WITH_CLEANUP(
    if ( key_file != NULL )
      g_key_file_free(key_file);
  );
}
#endif /* UNITTEST */

/****************************************************** }}}1 Misc Functions */
/* Exported Functions {{{1 **************************************************/
/* memdir_create()                                                     {{{2 */
/* Create a MemDir directory. */
gboolean
memdir_create( const gchar *name, guint chunk_size, guint file_size,
               guint alignment, GError **error )
{
  glong  page_size = -1;
  gint   result    = -1;
  MemDir md;

  g_assert( name  != NULL );
  g_assert( error == NULL || *error == NULL );
  g_assert( chunk_size <= file_size );

  /* file_size should be evenly divisible by chunk_size */
  g_assert( ROUND_DOWN(file_size, chunk_size) == file_size );

  /* if alignment is 0, use default */
  if ( alignment <= 0 )
    alignment = sizeof(int);

  g_assert( alignment  <  chunk_size );

  /* make sure chunk_size is multiple of system page size */
  page_size = memdir_get_page_size();
  if ( ROUND_DOWN( chunk_size, page_size ) != chunk_size ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
           "chunk size %d is not a multiple of system page size %ld, "
           "performance may be degraded and things may explode.",
           chunk_size, page_size );
  }

  /* create the directory. */
  result = g_mkdir(name, S_IRWXU);
  if ( result != 0 ) {
    if ( errno == EEXIST ) {
      g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_EXISTS,
                  "directory %s already exists", name );
    } else {
      g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_MKDIR,
                  "mkdir(%s, S_IRWXU): %s", name, g_strerror(errno) );
    }
    return FALSE;
  }

  /* write info file */
  md.chunk_size = chunk_size;
  md.file_size  = file_size;
  md.alignment  = alignment;
  md.next_pointer.file_number = 0;
  md.next_pointer.file_offset = 0;
  md.free_spaces = NULL;

  if ( memdir_write_info( name, &md, error ) != TRUE )
    return FALSE;

  return TRUE;

}

/* test_memdir_create()                                                {{{2 */
#if UNITTEST
static TestResult
test_memdir_create()
{
  gboolean  result    = FALSE;
  GError   *error     = NULL;
  gchar    *path      = NULL;
  glong     page_size = -1;

  /* get sys page size */
  page_size = memdir_get_page_size();

  /* try existing dir */
  result = memdir_create( test_path, page_size, page_size, 0, &error );
  TEST_ASSERT_ERROR( error, MEMDIR_ERROR, MEMDIR_ERROR_EXISTS );
  TEST_ASSERT( !result );

  /* try unknown mkdir error */
  test_set_mock_return_g_mkdir( -1 );
  test_set_mock_errno_g_mkdir( ENOTDIR );
  result = memdir_create( test_path, page_size, page_size, 0, &error );
  TEST_ASSERT_ERROR( error, MEMDIR_ERROR, MEMDIR_ERROR_MKDIR );
  TEST_ASSERT( !result );

  /* make a dir in our test dir */
  path = g_build_filename( test_path, MEMDIR_TEST_DIR, NULL );
  result = memdir_create( path, page_size, page_size, 0, &error );
  g_free( path );
  path = NULL;
  TEST_ASSERT_NO_ERROR( error );
  TEST_ASSERT( result );

  /* make sure info file exists */
  path = g_build_filename( test_path, MEMDIR_TEST_DIR,
                           MEMDIR_FILENAME_INFO, NULL );
  TEST_ASSERT( g_file_test( path, G_FILE_TEST_EXISTS ) );
  g_free(path);
  path = NULL;

  TEST_DONE();
}
#endif /* UNITTEST */

/* memdir_open()                                                       {{{2 */
/* Open a MemDir */
MemDir *
memdir_open(const gchar *name, GError **error)
{
  MemDir    *md         = NULL;
  gchar     *info_fname = NULL;
  gchar     *cwd        = NULL;
  GError    *kf_error   = NULL;
  GKeyFile  *key_file   = NULL;
  long       page_size  = -1;

  g_assert( name  != NULL );
  g_assert( error == NULL || *error == NULL );

  /* open the info file */
  key_file = g_key_file_new();

  info_fname = g_build_filename( name, MEMDIR_FILENAME_INFO, NULL );
  if ( g_key_file_load_from_file( key_file, info_fname,
                                  G_KEY_FILE_NONE, error ) != TRUE ) {
    goto error;
  }

  /* don't need info filename anymore */
  g_free(info_fname);
  info_fname = NULL;

  /* validate info file */
  if ( !g_key_file_has_group( key_file, "memdir" ) ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_INVALID_INFO,
                 "no memdir section in info file" );
    goto error;
  }

  if ( !g_key_file_has_key( key_file, "memdir", "version",     NULL ) ||
       !g_key_file_has_key( key_file, "memdir", "chunk_size",  NULL ) ||
       !g_key_file_has_key( key_file, "memdir", "file_size",   NULL ) ||
       !g_key_file_has_key( key_file, "memdir", "alignment",   NULL ) ||
       !g_key_file_has_key( key_file, "memdir", "file",        NULL ) ||
       !g_key_file_has_key( key_file, "memdir", "offset",      NULL ) ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_INVALID_INFO,
                 "info file is missing required keys" );
    goto error;
  }

  /* check version */
  if ( g_key_file_get_integer( key_file, "memdir", "version", NULL ) !=
       MEMDIR_INFO_VERSION ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_INVALID_INFO,
                 "info file is unrecognized version" );
    goto error;
  }

  /* create struct */
  md             = memdir_struct_new();

  /* get full path name */
  cwd = g_get_current_dir();
  md->path = g_build_path( G_DIR_SEPARATOR_S, cwd, name, NULL );
  g_free(cwd);
  cwd = NULL;

  /* load info */
  if ( kf_error == NULL )
    md->chunk_size =
      g_key_file_get_integer( key_file, "memdir", "chunk_size", &kf_error );

  if ( kf_error == NULL )
    md->file_size =
      g_key_file_get_integer( key_file, "memdir", "file_size", &kf_error );

  if ( kf_error == NULL )
    md->alignment =
      g_key_file_get_integer( key_file, "memdir", "alignment", &kf_error );

  if ( kf_error == NULL )
    md->next_pointer.file_number =
      g_key_file_get_integer( key_file, "memdir", "file", &kf_error );

  if ( kf_error == NULL )
    md->next_pointer.file_offset =
      g_key_file_get_integer( key_file, "memdir", "offset", &kf_error );

  /* read free space info if present */
  if ( kf_error == NULL )
    if ( g_key_file_has_group( key_file, "freespace" ) )
      memdir_free_space_load( key_file, md, &kf_error );

  if ( kf_error != NULL ) {
    g_propagate_error( error, kf_error );
    goto error;
  }

  /* done with keyfile */
  g_key_file_free( key_file );
  key_file = NULL;

  /* make sure chunk_size is multiple of system page size */
  page_size = memdir_get_page_size();
  if ( ROUND_DOWN( md->chunk_size, page_size ) != md->chunk_size ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
           "chunk size %d is not a multiple of system page size %ld, "
           "performance may be degraded and things may explode.",
           md->chunk_size, page_size );
  }

  if ( memdir_mmap_next_chunk(md, error) != TRUE )
    goto error;

  return md;

error:
  if ( info_fname != NULL )
    g_free( info_fname );
  if ( key_file != NULL )
    g_key_file_free( key_file );
  if ( md != NULL )
    memdir_struct_free(md);
  if ( key_file != NULL )
    g_key_file_free( key_file );
  return NULL;
}

/* memdir_alloc()                                                      {{{2 */
/* Allocate space in a MemDir. */
void *
memdir_alloc( MemDir *md, MemDirSize size, MemDirPointer *pointer,
              GError **error )
{
  MemDirSize  full_size = 0;
  guint32    *data      = NULL;
  GList      *fslp      = NULL;

  g_assert( md      != NULL );
  g_assert( pointer != NULL );
  g_assert( size     > 0    );
  g_assert( error   == NULL || *error == NULL );

  /* see if there's a free slot */
  fslp = g_list_find_custom( md->free_spaces, GUINT_TO_POINTER(size),
                             memdir_free_space_find_by_size );

  if ( fslp != NULL ) {
    GError          *load_error = NULL;
    MemDirFreeSpace *fs         = fslp->data;

    /* size should be exactly equal, or big enough to split */
    g_assert( fs->length == size ||
              fs->length >= (size + SSIZEOF(MemDirSize)) );

    /* load the free spot */
    data = memdir_load( md, fs->start, NULL, error );

    if ( data != NULL ) {
      /* whether to fall through and try to alloc normally instead */
      gboolean fall_through = FALSE;

      /* if free space is bigger than we are using */
      if ( fs->length > size ) {
        /* make sure there's enough room to create another free block */
        if ( (fs->length - size) < SSIZEOF(MemDirSize) ) {
          /* shouldn't happen */
          g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
                "got %d bytes of free space for requested %d - "
                "not enough room to split",
                fs->length, size );
          fall_through = TRUE;
        } else {
          MemDirSize aligned_size = 0;

          /* jump to end of our data (respect alignment) */
          aligned_size = ROUND_UP(size, md->alignment);

          /* add new free space */
          memdir_free_space_add( md, fs->start.file_number,
                                 fs->start.file_offset + aligned_size,
                                 fs->length - aligned_size,
                                 FALSE );

        }
      } else if ( fs->length < size ) {
        /* shouldn't happen */
        g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
              "got %d bytes of free space for requested %d!",
              fs->length, size );
        fall_through = TRUE;
      }

      /* if everything's still ok */
      if ( !fall_through ) {
        g_log( G_LOG_DOMAIN, G_LOG_LEVEL_DEBUG,
               "reusing %d free space at %d.%d for %d alloc",
               fs->length, fs->start.file_number, fs->start.file_offset,
               size);

        /* update size */
        *(data - 1) = size;

        /* set the start pointer */
        *pointer = fs->start;

        /* remove free space from list */
        memdir_free_space_remove( md, fs->start.file_number,
                                      fs->start.file_offset );

        return data;
      }

    } else {
      /* couldn't load */
      g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
             "error trying to re-use free space at %d:%d: %s",
             fs->start.file_number, fs->start.file_offset,
             load_error ? load_error->message : "unknown error" );
      /* fall through and try to alloc new space */
    }
  }

  /* add room for size */
  full_size = size + sizeof(guint32);

  /* respect alignment UNLESS at end of chunk */
  if ( md->cur_chunk->free != full_size )
    full_size = ROUND_UP( full_size, md->alignment );

  /* make sure it's possible to fit */
  if ( full_size > md->chunk_size ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_SIZE,
                 "alloc(%d) is too big for chunk size %d",
                 size, md->chunk_size );
    return NULL;
  }

  /* make sure there's enough space */
  if ( md->cur_chunk->free < full_size ) {
    /* tag remaining space in chunk as free */
    if ( md->cur_chunk->free > SSIZEOF(MemDirFreeSpace) ) {
      memdir_free_space_add( md,
                             md->next_pointer.file_number,
                             md->next_pointer.file_offset,
                             md->cur_chunk->free,
                             FALSE );
    }

    /* map next chunk */
    if ( memdir_mmap_next_chunk( md, error ) != TRUE )
      return NULL;
  }

  g_assert( md->cur_chunk->free >= full_size );

  pointer->file_number = md->next_pointer.file_number;
  pointer->file_offset = md->next_pointer.file_offset;

  data = (guint32*)md->cur_chunk->cur;

  /* store length */
  *data++ = GUINT32_TO_LE( size );

  /* update md */
  md->next_pointer.file_offset += full_size;
  md->cur_chunk->cur           += full_size;
  md->cur_chunk->free          -= full_size;

  /* increase chunk refcount */
  md->cur_chunk->ref_count      += 1;

  /* track alloc */
  memdir_alloc_add( md, md->cur_chunk, *pointer, size, data );

  return data;
}

/* memdir_load()                                                       {{{2 */
/* Load data from MemDir. */
void *
memdir_load( MemDir *md, MemDirPointer pointer, MemDirSize *out_length,
             GError **error )
{
  MemDirPointer  start;
  MemDirChunk   *chunk;
  gchar         *data;
  MemDirSize     length;

  g_assert( md     != NULL );
  g_assert( error  == NULL || *error == NULL );

  /* make sure pointer is valid */
  if ( pointer.file_number > md->cur_chunk->start.file_number ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_INVALID_POINTER,
                 "pointer in nonexistant file: %d (at %d)",
                 pointer.file_number, md->cur_chunk->start.file_number );
    return NULL;
  }

  if ( (pointer.file_number == md->next_pointer.file_number) &&
       (pointer.file_offset  > md->next_pointer.file_offset) ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_INVALID_POINTER,
                 "pointer past current offset: %08x (at %08x)",
                 pointer.file_offset, md->cur_chunk->start.file_offset );
    return NULL;
  }

  /* find start of containing chunk */
  start.file_number = pointer.file_number;
  start.file_offset = ROUND_DOWN( pointer.file_offset, md->chunk_size );

  /* see if chunk is already open */
  chunk = g_hash_table_lookup( md->chunks, &start );

  /* load chunk if necessary */
  if ( chunk == NULL ) {
    chunk = memdir_chunk_open( md, start, error );
    if ( chunk == NULL )
      return NULL;
  }

  /* find data */
  data = chunk->base + (pointer.file_offset - chunk->start.file_offset);

  /* read length (free space uses negative numbers) */
  length = abs( *((MemDirSize*)data) );
  if ( out_length != NULL )
    *out_length = length;

  data += sizeof(MemDirSize);

  /* increase chunk ref count */
  chunk->ref_count += 1;

  /* track alloc */
  memdir_alloc_add( md, chunk, pointer, length, data );

  /* done */
  return data;
}

/* memdir_unref()                                                      {{{2 */
/* Finish with memory from memdir_load() or memdir_alloc() */
gboolean
memdir_unref( MemDir *md, void *data, GError **error )
{
  MemDirAlloc *alloc = NULL;

  g_assert( md     != NULL );
  g_assert( data   != NULL );
  g_assert( error  == NULL || *error == NULL);

  alloc = g_hash_table_lookup( md->allocs, data );
  if ( alloc == NULL ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_INVALID_DATA,
                 "no alloc info for data at %p", data );
    return FALSE;
  }

  alloc->ref_count -= 1;

  /* if last reference */
  if ( alloc->ref_count == 0 ) {
    /* decrease chunk ref count */
    g_assert( alloc->chunk->ref_count != 0 );
    alloc->chunk->ref_count -= 1;

    if ( alloc->chunk->ref_count == 0 ) {
      /* free chunk if there's no references and it's not a current one */
      if ( alloc->chunk != md->cur_chunk )
        memdir_chunk_close(alloc->chunk);
    }

    /* remove the alloc */
    g_hash_table_remove( md->allocs, data );
  }

  return TRUE;
}

/* memdir_free()                                                       {{{2 */
/* Free memory in map, allowing it to be reused */
gboolean
memdir_free( MemDir *md, void *data, GError **error )
{
  MemDirAlloc *alloc  = NULL;
  MemDirChunk *chunk  = NULL;
  gboolean     result = FALSE;

  g_assert( md     != NULL );
  g_assert( data   != NULL );
  g_assert( error  == NULL || *error == NULL);

  alloc = g_hash_table_lookup( md->allocs, data );
  if ( alloc == NULL ) {
    g_set_error( error, MEMDIR_ERROR, MEMDIR_ERROR_INVALID_DATA,
                 "no alloc info for data at %p", data );
    return FALSE;
  }

  alloc->ref_count -= 1;

  /* warn if not last reference */
  if ( alloc->ref_count != 0 ) {
    g_log( G_LOG_DOMAIN, G_LOG_LEVEL_WARNING,
           "freeing alloc with %d references remaining!",
           alloc->ref_count );
  }

  /* get chunk data is in */
  chunk = alloc->chunk;

  /* add new space to list */
  result = memdir_free_space_add( md,
                                  alloc->start.file_number,
                                  alloc->start.file_offset-sizeof(MemDirSize),
                                  alloc->length+sizeof(MemDirSize),
                                  TRUE );

  /* remove the alloc */
  g_hash_table_remove( md->allocs, data );

  /* decrease chunk ref count */
  memdir_chunk_unref( chunk );

  return result;
}

/* memdir_close()                                                      {{{2 */
/* Close a MemDir. */
gboolean
memdir_close(MemDir *md, GError **error)
{
  g_assert( md    != NULL );
  g_assert( error == NULL || *error == NULL );

  /* store cur file and offset */
  if ( memdir_write_info( md->path, md, error ) != TRUE )
    return FALSE;

  /* free memory */
  memdir_struct_free(md);

  return TRUE;
}

/* memdir_get_page_size()                                              {{{2 */
/* FIXME: this function needs to be renamed (see windows note) */
long
memdir_get_page_size()
{
  static long page_size = 0;
  if ( page_size )
    return page_size;
#ifdef WIN32
  {
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    /* on windows we have to map on multiples of the "allocation granularity"
     * and not the system page size. */
    return page_size = si.dwAllocationGranularity; /*dwPageSize;*/
  }
#else /* !WIN32 */
  return page_size = sysconf(_SC_PAGE_SIZE);
#endif
}

/* memdir_offset_to_pointer()                                          {{{2 */
/* Translate an absolute 64-bit offset into a MemDirPointer.  */
MemDirPointer
memdir_offset_to_pointer(MemDir *md, guint64 offset)
{
  MemDirPointer mdp;
  g_assert( md != NULL );
  mdp.file_number = offset / md->file_size;
  mdp.file_offset = offset % md->file_size;
  return mdp;
}

/* test_memdir_offset_to_pointer()                                     {{{2 */
#if UNITTEST
static TestResult
test_memdir_offset_to_pointer()
{
  MemDirPointer mdp;
  MemDir        md;

  md.file_size = 16;
  mdp = memdir_offset_to_pointer( &md, 32 );
  TEST_ASSERT_EQUAL_INT( mdp.file_number, 2 );
  TEST_ASSERT_EQUAL_INT( mdp.file_offset, 0 );

  md.file_size = 24;
  mdp = memdir_offset_to_pointer( &md, 32 );
  TEST_ASSERT_EQUAL_INT( mdp.file_number, 1 );
  TEST_ASSERT_EQUAL_INT( mdp.file_offset, 8 );

  md.file_size = 32;
  mdp = memdir_offset_to_pointer( &md, 32 );
  TEST_ASSERT_EQUAL_INT( mdp.file_number, 1 );
  TEST_ASSERT_EQUAL_INT( mdp.file_offset, 0 );

  md.file_size = 64;
  mdp = memdir_offset_to_pointer( &md, 32 );
  TEST_ASSERT_EQUAL_INT( mdp.file_number, 0 );
  TEST_ASSERT_EQUAL_INT( mdp.file_offset, 32 );

  TEST_DONE();
}
#endif /* UNITTEST */

/* memdir_current_offset()                                             {{{2 */
guint64
memdir_current_offset(MemDir *md)
{
  g_assert( md != NULL );
  return ( md->next_pointer.file_number * md->file_size ) +
           md->next_pointer.file_offset;
}

/************************************************** }}}1 Exported Functions */
/* Test Suite {{{1 **********************************************************/

#if UNITTEST
TestSuiteResult
test_suite_memdir_unit() {

  /* simple tests */
  TEST_RUN_TEST(test_memdir_free_space_comp);
  TEST_RUN_TEST(test_memdir_pointer_equal);
  TEST_RUN_TEST(test_memdir_free_space_load);
  TEST_RUN_TEST(test_memdir_free_space_find_by_size);
  TEST_RUN_TEST(test_memdir_offset_to_pointer);

  /* tests that need temp file */
  test_suite_set_setup(test_temp_file_setup);
  test_suite_set_teardown(test_temp_file_teardown);

  TEST_RUN_TEST(test_memdir_extend_file);

  /* tests that need temp dir */
  test_suite_set_setup(test_dir_setup);
  test_suite_set_teardown(test_dir_teardown);

  TEST_RUN_TEST(test_memdir_open_file_number);
  TEST_RUN_TEST(test_memdir_write_info);
  TEST_RUN_TEST(test_memdir_create);

}
#endif /* UNITTEST */

/********************************************************** }}}1 Test Suite */
/****************************************************************************/
