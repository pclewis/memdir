/** @file test/memdir.c
 *  MemDir functional tests
 */

/*
 * Copyright (C) 2006 Philip Lewis <pcl@pclewis.com>
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/****************************************************************************/
/****************************************************************************/

/* compatibility stuff - must come first */
#include "compat.h"

#ifndef WIN32
#include <unistd.h>
#endif
#include <string.h>
#include <sys/types.h>

#include <glib.h>
#include <glib/gprintf.h>

#include "misc.h"
#include "memdir.h"
#include "test.h"

/****************************************************************************/
/****************************************************************************/

#define MEMDIR_TEST_DIR       "__test_memdir__"
#define MEMDIR_TEST_DATA_FMT  "0123456789 test data %04x \1\2\3"
#define MEMDIR_TEST_DATA_LEN  (30+1)
#define MEMDIR_TEST_ITEMS     4096
#define MEMDIR_CHUNK_SIZE     ((MEMDIR_TEST_ITEMS * sizeof(MemDirPointer))*2)

static TestResult
test_memdir_base(gint chunk_size)
{
  GError        *error      = NULL;
  MemDir        *memdir     = NULL;
  gchar         *data       = NULL;
  gchar         *str        = NULL;
  MemDirPointer  base_ptr;
  MemDirPointer *ptrs       = NULL;
  int            i          = 0;
  gchar         *data_ptrs[MEMDIR_TEST_ITEMS];


  /* create memdir */
  TEST_REQUIRE( TEST_ASSERT( memdir_create( MEMDIR_TEST_DIR, chunk_size,
                                            chunk_size, 0, &error ) ) );
  TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );

  /* open it */
  memdir = memdir_open( MEMDIR_TEST_DIR, &error );
  TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error  ) );
  TEST_REQUIRE( TEST_ASSERT_NOT_NULL( memdir ) );

  /* allocate space for pointers */
  ptrs = memdir_alloc( memdir,    sizeof(MemDirPointer) * MEMDIR_TEST_ITEMS,
                       &base_ptr, &error );
  TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );
  TEST_REQUIRE( TEST_ASSERT_NOT_NULL( ptrs  ) );

  /* allocate pointers and write some data */
  for ( i = 0; i < MEMDIR_TEST_ITEMS; ++i ) {
    data = memdir_alloc(memdir, MEMDIR_TEST_DATA_LEN,
                        ptrs+i, &error);

    TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );
    TEST_REQUIRE( TEST_ASSERT_NOT_NULL( data ) );

    g_snprintf( data, MEMDIR_TEST_DATA_LEN,
                MEMDIR_TEST_DATA_FMT, i );

    memdir_unref(memdir, data, &error);

    TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );
  }

  /* close */
  TEST_REQUIRE( TEST_ASSERT( memdir_close( memdir, &error ) ) );
  TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );

  /* open it back up */
  memdir = memdir_open( MEMDIR_TEST_DIR, &error );
  TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );
  TEST_REQUIRE( TEST_ASSERT_NOT_NULL( memdir ) );

  /* load the pointers */
  ptrs = memdir_load( memdir, base_ptr, NULL, &error );
  TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );
  TEST_REQUIRE( TEST_ASSERT_NOT_NULL( ptrs ) );

  /* make sure they're all correct */
  for ( i = 0; i < MEMDIR_TEST_ITEMS; ++i ) {
    MemDirSize length;
    data = memdir_load( memdir, *(ptrs+i), &length, &error );
    TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );
    TEST_REQUIRE( TEST_ASSERT_NOT_NULL( data ) );
    TEST_REQUIRE( TEST_ASSERT_EQUAL_INT( length, MEMDIR_TEST_DATA_LEN ) );

    str = g_strdup_printf( MEMDIR_TEST_DATA_FMT, i );
    TEST_REQUIRE( TEST_ASSERT_EQUAL_STRING( data, str ) );
    g_free(str); str = NULL;

    data_ptrs[i] = data;
  }

  /* check again, in reverse */
  for ( i = MEMDIR_TEST_ITEMS; i--; ) {
    str = g_strdup_printf( MEMDIR_TEST_DATA_FMT, i );
    TEST_REQUIRE( TEST_ASSERT_EQUAL_STRING( data_ptrs[i], str ) );
    g_free(str);
  }

  /* and one more time, unreffing as we go */
  for ( i = 0; i < MEMDIR_TEST_ITEMS; ++i ) {
    MemDirSize length;

    str = g_strdup_printf( MEMDIR_TEST_DATA_FMT, i );
    TEST_REQUIRE( TEST_ASSERT_EQUAL_STRING( data_ptrs[i], str ) );

    /* try loading it again */
    data = memdir_load( memdir, *(ptrs+i), &length, &error );
    TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );
    TEST_REQUIRE( TEST_ASSERT_NOT_NULL( data ) );
    TEST_REQUIRE( TEST_ASSERT_EQUAL_INT( length, MEMDIR_TEST_DATA_LEN ) );
    TEST_REQUIRE( TEST_ASSERT_EQUAL_STRING( data, str ) );

    /* unref second copy and try original again */
    memdir_unref( memdir, data, &error );
    TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );

    TEST_REQUIRE( TEST_ASSERT_EQUAL_STRING( data_ptrs[i], str ) );

    /* free string and unref original */
    g_free(str); str = NULL;
    memdir_unref(memdir, data_ptrs[i], &error);
    TEST_REQUIRE( TEST_ASSERT_NO_ERROR( error ) );
  }

  /* all done */
  TEST_DONE_WITH_CLEANUP(
    g_free(str);
    memdir_close( memdir, &error );
    rmrf( MEMDIR_TEST_DIR );
  );
}

static TestResult
test_memdir_simple()
{
  long page_size  = -1;
  gint chunk_size = -1;

  page_size  = memdir_get_page_size();
  chunk_size = ROUND_UP( MEMDIR_CHUNK_SIZE, page_size );

  return test_memdir_base(chunk_size);
}

static TestResult
test_memdir_misaligned_chunks()
{
  long page_size  = -1;
  gint chunk_size = -1;

  page_size   = memdir_get_page_size();
  chunk_size  = ROUND_UP( MEMDIR_CHUNK_SIZE, page_size );
  chunk_size += (page_size/2)-1;

  return test_memdir_base(chunk_size);
}

/****************************************************************************/
/****************************************************************************/

TestSuiteResult
test_suite_memdir_functional()
{
  TEST_RUN_TEST( test_memdir_simple );
  TEST_RUN_TEST( test_memdir_misaligned_chunks );
}

